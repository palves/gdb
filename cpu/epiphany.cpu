; Adapteva EPIPHANY CPU description. -*- Scheme -*-
; Copyright 1998, 1999, 2000, 2001, 2003, 2006, 2007, 2008, 2009, 2010, 2011
; Free Software Foundation, Inc.
;
; Contributed by Embecosm on behalf of Adapteva, Inc.
; This file is part of the GNU Binutils and of GDB.
;
; This program is free software; you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation; either version 3 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program; if not, write to the Free Software
; Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
; MA 02110-1301, USA.

(define-rtl-version 0 9)

(include "simplify.inc")
					; define-arch must appear first

(define-arch
  (name epiphany) ; name of cpu family
  (comment "Adapteva, Inc. EPIPHANY family")
  (default-alignment aligned)
  (insn-lsb0? #t)

					; - a 16/32 bit instruction machine (the default)

  (machs epiphany32)
  (isas epiphany)
  )

					; Attributes.

(define-attr
  (for insn)
  (type boolean)
  (name SHORT-INSN)
  (comment "instruction is a 16 bit form")
  )

;; 3 bit add/sub immediate forms - useful for relaxing into 11 bit form
(define-attr
  (for insn)
  (type boolean)
  (name IMM3)
  (comment "instruction has a 3 bit immediate form")
  )

;; 8 bit mov immediate forms - useful for relaxing into 16 bit form
(define-attr
  (for insn)
  (type boolean)
  (name IMM8)
  (comment "instruction has a 8 bit immediate form")
  )

					; Instruction set parameters.

(define-isa
  (name epiphany)
  (comment "Adapteva, Inc. EPIPHANY32 ISA")

  (default-insn-word-bitsize 32)
  (default-insn-bitsize 32)
  (base-insn-bitsize 32)
  (decode-assist (3 2 1 0))  ; CGEN can figure this out
  (liw-insns 1)				; # instructions fetched at once
  )

					; Cpu family definitions.


(define-cpu
					; cpu names must be distinct from the architecture name and machine names.
  (name epiphanybf)
  (comment "Adapteva, Inc. EPIPHANY Family")
  (endian little)
  (word-bitsize 32)
  )

(define-cpu
  (name epiphanymf)
  (comment "Adapteva, Inc. EPIPHANY Family")
  (endian little)
  (word-bitsize 32)
  )


(define-mach
  (name epiphany32)
  (comment "Adapteva EPIPHANY")
  (cpu epiphanybf)
  )


					; Model descriptions.

(define-model
  (name epiphany32) (comment "Adapteva EPIPHANY 32/16") (attrs)
  (mach epiphany32)

  (unit u-exec "Execution Unit" ()
	1 1 ; issue done
	() ; state
	() ; inputs
	() ; outputs
	() ; profile action (default)
	)
  )



					; Instruction fields.
					;
					; Attributes:
					; XXX: what EPIPHANY attrs
					; PCREL-ADDR: pc relative value (for reloc and disassembly purposes)
					; ABS-ADDR: absolute address (for reloc and disassembly purposes?)
					; RESERVED: bits are not used to decode insn, must be all 0
					; RELOC: there is a relocation associated with this field

(define-attr
  (for ifield operand)
  (type boolean)
  (name RELOC)
  (comment "there is a reloc associated with this field (experiment)")
  )

;; define the fields of the instruction.
;;   name            description              ATTR  MSB LEN
(dnf f-opc	  "primary opcode"	       ()     3 4)
(dnf f-opc-4-1    "secondary opcode"           ()     4 1)
(dnf f-opc-6-3    "secondary opcode"           ()     6 3) ;;
(dnf f-opc-8-5    "tertiary opcode"            ()     8 5) ;;
(dnf f-opc-19-4   "additional opcode bits"     ()    19 4)
(dnf f-condcode   "condition codes" 	       ()     7 4)
(dnf f-secondary-ccs "flag for secondary ccs"  ()     7 1)
(dnf f-shift      "shift amount"               ()     9 5)
(dnf f-wordsize   "load/store size"            ()     6 2)
(dnf f-store      "load/store flag"            ()     4 1) ;; 0==load,1==store
(dnf f-opc-8-1    "opcode bits"                ()     8 1)
(dnf f-opc-31-32  "all opcode set"             ()     31 32)

(df f-simm8	  "branch displacement"   (PCREL-ADDR RELOC) 15 8 INT
    ((value pc) (sra SI (sub SI value pc) 1))
    ((value pc) (add SI (sll SI value 1) pc)))

(df f-simm24     "branch displacement"	  (PCREL-ADDR RELOC) 31 24 INT
    ((value pc) (sra SI (sub SI value pc) 1))
    ((value pc) (add SI (sll SI value 1) pc)))

(df f-sdisp3     "signed immediate 3 bit"      ()     9 3  INT #f #f)

(dnf f-disp3      "address offset"             ()     9 3)
(dnf f-disp8      "address offset"             ()    23 8)

(dnf f-imm8      "move/add/sub imm8"           ()    12 8)
(dnf f-imm-27-8  "move/add/sub imm16"          ()    27 8)
(dnf f-addsubx   "+/- index address"           ()    20 1)
(dnf f-subd      "+/- displ address"           ()    24 1)
(dnf f-pm        "post-modify immediate"       ()    25 1)

(dnf f-rm        "short rm"                    ()     9 3)   ;; RM
(dnf f-rn        "short rn"                    ()    12 3)   ;; RN
(dnf f-rd        "short rd"                    ()    15 3)   ;; RD

(dnf f-rm-x       "extension rm"               ()    25 3)   ;; RM
(dnf f-rn-x       "extension rn"               ()    28 3)   ;; RN
(dnf f-rd-x       "extension rd"               ()    31 3)   ;; RD

(dnf f-dc-9-1     "DC"                 (RESERVED)     9 1)

(dnf f-sn        "short sn"                    ()    12 3)   ;; SN
(dnf f-sd        "short sd"                    ()    15 3)   ;; SD

(dnf f-sn-x       "extension sn"               ()    28 3)   ;; SN
(dnf f-sd-x       "extension sd"               ()    31 3)   ;; SD



(dnf f-dc-7-4     "movts zeros"                 ()     7 4)
(dnf f-trap-swi-9-1     "trap or swi"                 ()     9 1)
(dnf f-gien-gidis-9-1     "gien or gidis"                 ()     9 1)


(dnf f-dc-15-3    "DC"                 (RESERVED)    15 3)
(dnf f-dc-15-7    "DC"                 (RESERVED)    15 7)
(dnf f-dc-15-6    "DC"                 ()            15 6)
(dnf f-trap-num   "trap number"                ()    15 6)

(dnf f-dc-20-1    "DC"                 (RESERVED)    20 1)

(dnf f-dc-21-1    "DC"                 (RESERVED)    21 1)
(dnf f-dc-21-2    "DC"                 (RESERVED)    21 2)

(dnf f-dc-22-3    "DC"                 (RESERVED)    22 3)
(dnf f-dc-22-2    "DC"                 (RESERVED)    22 2)
(dnf f-dc-22-1    "DC"                 (RESERVED)    22 1)

(dnf f-dc-25-6    "DC"                 (RESERVED)    25 6)
(dnf f-dc-25-4    "DC"                 (RESERVED)    25 4)
(dnf f-dc-25-2    "DC"                 (RESERVED)    25 2)
(dnf f-dc-25-1    "DC"                 (RESERVED)    25 1)

(dnf f-dc-28-1    "DC"                 (RESERVED)    28 1)
(dnf f-dc-31-3    "DC"                 (RESERVED)    31 3)

(dnmf f-disp11 "Unsigned offset for load/store" () UINT (f-disp3 f-disp8)
      (sequence ()
		(set (ifield f-disp8) (and (srl (ifield f-disp11) 3) (const 255)))
		(set (ifield f-disp3) (and (ifield f-disp11) 7)))
      (sequence ()
		(set (ifield f-disp11) (or (sll (ifield f-disp8) 3)
					   (ifield f-disp3)))
		)
      )


(dnmf f-sdisp11 "Signed offset for load/store" () INT (f-disp3 f-disp8)
      (sequence ()			;encode
		(set (ifield f-disp8) (and #xff (srl SI (ifield f-sdisp11) 3)))
		(set (ifield f-disp3)  (and SI (ifield f-sdisp11) 7)))
      (sequence ()			;decode
		(set (ifield f-sdisp11)
		     (sra SI (sll SI (or SI (sll (ifield f-disp8) 3)
					 (ifield f-disp3))
				  21)
			  21)))
      )

(dnmf f-imm16 "Short immediate for move/add/sub" () UINT (f-imm8 f-imm-27-8)
      (sequence ()
		(set (ifield f-imm8) (and (ifield f-imm16) #xff))
		(set (ifield f-imm-27-8) (srl (ifield f-imm16) 8)))
      (sequence ()
		(set (ifield f-imm16) (or (sll (ifield f-imm-27-8) 8)
					  (ifield f-imm8))))
      )


;; 32 bit instructions have the register number broken into two non-contiguous fields

(define-pmacro (x-reg-field reg)
  (define-multi-ifield
    (name (%sym "f-" reg "6"))
    (mode UINT)
    (subfields (%sym "f-" reg "-x") (%sym "f-" reg))
    (insert (sequence ()
		      (set (ifield (%sym "f-" reg))   (and (ifield (%sym "f-" reg "6"))
							   (const 7)))
		      (set (ifield (%sym "f-" reg "-x"))  (srl (ifield (%sym "f-" reg "6"))
							       (const 3)))
		      ))
    (extract (sequence ()
		       (set (ifield (%sym "f-" reg "6")) (or (sll (ifield (%sym "f-" reg "-x"))
								  (const 3))
							     (ifield (%sym "f-" reg))))
		       ))
    )
  )

(x-reg-field rd)			; f-rd6
(x-reg-field rn)			; f-rn6
(x-reg-field rm)			; f-rm6
(x-reg-field sd)			; f-sd6
(x-reg-field sn)			; f-sn6


;;;;;;;;;;
					; Enums. ;
;;;;;;;;;;

					; insn-opc: bits 3..0 - major family selector
(define-normal-insn-enum insn-opc "opc enums" () OP4_ f-opc
  (
   BRANCH16  ;; 0000
   LDSTR16X  ;; 0001
   FLOW16    ;; 0010
   IMM16     ;; 0011
   LDSTR16D  ;; 0100
   LDSTR16P  ;; 0101
   LSHIFT16  ;; 0110 - logical shift
   DSP16     ;; 0111 - 3 reg DSP 16 bit insns
   BRANCH    ;; 1000
   LDSTRX    ;; 1001
   ALU16     ;; 1010 - 3 reg 16 bit
   IMM32     ;; 1011
   LDSTRD    ;; 1100
   LDSTRP    ;; 1101
   ASHIFT16  ;; 1110   ASR, BITR
   MISC      ;; 1111 - 32 bit shifts, 3 reg ALU, 3 reg DSP, FLOW, BITR
   )
  )

(define-normal-insn-enum insn-wordsize "memory access width" () OPW_ f-wordsize
					; specifies the size of a memory load/store operation
  (BYTE SHORT WORD DOUBLE)
  )

(define-normal-insn-enum insn-memory-access "memory access direction" () OP_ f-store
					; load=0, store=1
  (LOAD STORE)
  )

					; enum for trap codes used by simulator
(define-normal-insn-enum trap-codes "trap instruction dispatch code" () TRAP_ f-trap-num
  (write read open exit pass fail close other)
  )

					; cond branch: bits 7..4
					;
(define-normal-insn-enum insn-cond "branch conditions" () OPC_ f-condcode
  (EQ NE GTU GTEU LTEU LTU GT GTE LT LTE BEQ BNE BLT BLTE B BL))

					; dsp 3 operand opcodes
(define-normal-insn-enum insn-bop "binary operator subcodes" () OPB_ f-opc-6-3
  (EOR ADD LSL SUB LSR AND ASR ORR))

					; dsp 3 operand opcodes
(define-normal-insn-enum insn-bopext "binary operator subcodes" () OPBE_ f-opc-6-3
  (FEXT FDEP LFSR - - - - -))


(define-normal-insn-enum insn-fop "floating operators" () OPF_ f-opc-6-3
  (ADD SUB MUL MADD MSUB FLOAT FIX FABS))

(define-normal-insn-enum insn-fopexn "extended floating operators" () OPF_ f-opc-6-3
  (FRECIP FSQRT - - - - - -))




; Immediate operation secondary opcodes
(define-normal-insn-enum insn-immop "immediate operators" () OPI_ f-opc-6-3
  (- ADD - SUB - - - TRAP) ; TRAP is special extension for simulator
  )

					; don't care fields
(define-normal-insn-enum insn-dc-25-2 "don't cares" () OPI_25_2_ f-dc-25-2
  (MBZ))


(define-keyword
  (name all-reg-names)
  (comment "register num as per MMR map")
  (enum-prefix H-REG-)
  (name-prefix "")
  (values
	(NUM-REGS 512)
	; GPR group
	; some preferred aliases
	(SP 13) (LR 14) (FP 15)
	; the default register names
	(R0  0)  (R1   1) (R2   2) (R3   3) (R4   4) (R5   5) (R6   6) (R7   7)
	(R8  8)  (R9   9) (R10 10) (R11 11) (R12 12) (R13 13) (R14 14) (R15 15)
	(R16 16) (R17 17) (R18 18) (R19 19) (R20 20) (R21 21) (R22 22) (R23 23)
	(R24 24) (R25 25) (R26 26) (R27 27) (R28 28) (R29 29) (R30 30) (R31 31)
	(R32 32) (R33 33) (R34 34) (R35 35) (R36 36) (R37 37) (R38 38) (R39 39)
	(R40 40) (R41 41) (R42 42) (R43 43) (R44 44) (R45 45) (R46 46) (R47 47)
	(R48 48) (R49 49) (R50 50) (R51 51) (R52 52) (R53 53) (R54 54) (R55 55)
	(R56 56) (R57 57) (R58 58) (R59 59) (R60 60) (R61 61) (R62 62) (R63 63)
	; some less popular aliases
	(A1  0) (A2  1) (A3  2) (A4  3) (V1  4) (V2  5) (V3  6) (V4  7)
	(V5  8) (V6  9) (V7 10) (V8 11)
	(SB  9) (SL 10) (IP 12)

	;; SCR group
	(SCR-CONFIG      #x100) ;; configuration register
	(SCR-STATUS      #x101) ;; unified condition codes
	(SCR-PC          #x102) ;; program counter                        CORE  RD/WR*
	(SCR-DEBUGSTATUS #x103) ;; debug status register                  CORE  RD/WR     used by debugger tools only
	(SCR-IAB         #x104) ;; iab fifo register for external fetch   CORE  WR*       external instruction fetch return register. Don't use.
	(SCR-LC          #x105) ;; hw loop counter                        CORE  RD/WR
	(SCR-LS          #x106) ;; hardware loop start                    CORE  RD/WR
	(SCR-LE          #x107) ;; hardware loop end                      CORE  RD/WR
	(SCR-IRET        #x108) ;; interrupt return register              CORE  RD/WR
	(SCR-IMASK       #x109) ;; interrupt masking register             CORE  RD/WR
	(SCR-ILAT        #x10a) ;; interrupt latch register               CORE  RD/WR*
	(SCR-ILATST      #x10b) ;; interrupt latch register bit set       CORE  WR
	(SCR-ILATCL      #x10c) ;; interrupt latch register bit clear     CORE  WR
	(SCR-IPEND       #x10d) ;; interrupt servicing interrupts         CORE  RD/WR*
	(SCR-CTIMER0     #x10e) ;; event counter                          CORE  RD/WR
	(SCR-CTIMER1     #x10f) ;; event counter                          CORE  RD/WR
	(SCR-FSTATUS     #x110) ;; ?? flush status register (raw access?) CORE  WR
	(SCR-FCONFIG     #x111) ;; ?? flush config register (raw access?)
	(SCR-DEBUGCMD    #x112) ;; debug command register                 CORE  WR

	;; DMA group
	(DMA0-CONFIG    #x140) ;; configuration register                 DMA   RD/WR
	(DMA0-STRIDE    #x141) ;; stride register                        DMA   RD/WR
	(DMA0-COUNT     #x142) ;; count register                         DMA   RD/WR
	(DMA0-SRCADDR   #x143) ;; source register                        DMA   RD/WR
	(DMA0-DSTADDR   #x144) ;; destination register                   DMA   RD/WR
	(DMA0-AUTO0     #x145) ;; autodma register                       DMA   RD/WR
	(DMA0-AUTO1     #x146) ;; autodma register                       DMA   RD/WR*
	(DMA0-STATUS    #x147) ;; dma status register                    DMA   RD/WR*
	(DMA1-CONFIG    #x148) ;; (samed as dma0*)
	(DMA1-STRIDE    #x149)
	(DMA1-COUNT     #x14a)
	(DMA1-SRCADDR   #x14b)
	(DMA1-DSTADDR   #x14c)
	(DMA1-AUTO0     #x14d)
	(DMA1-AUTO1     #x14e)
	(DMA1-STATUS    #x14f)

	;; Memory Protection Registers
	(MEM-CONFIG     #x180) ;; Forums: test register for the local SRAM (ignore, has not logical effect)
	(MEM-STATUS     #x181) ;; Memory protection status
	(MEM-PROTECT    #x182) ;; Memory protection configuration
	(MEM-RESERVE    #x183) ;; Forums: no idea should probably be removed :D

	;; MESH group
	(MESH-CONFIG         #x1c0) ;; mesh control register                 MESH   RD/WR
	(MESH-COREID         #x1c1) ;; mesh status and ID register           MESH   RD
	(MESH-MULTICAST      #x1c2) ;; multicast address                     MESH   RD/WR
	(MESH-RESETCORE      #x1c3) ;; core specific software reset                 WR
	(MESH-CMESHROUTE     #x1c4) ;; Not available on Epiphany-III
	(MESH-XMESHROUTE     #x1c5) ;; Not available on Epiphany-III
	(MESH-RMESHROUTE     #x1c6) ;; Not available on Epiphany-III
  )
)

(define-enum
  (name e-register-group-offsets)
  (comment "register group offsets in MMR region")
  (prefix H-REG-GRP-)
  (values
    (
	  ("GPR-OFFSET"      0) ;; General Purpose Registers (R0-R63)
	  ("SCR-OFFSET"  #x100) ;; Special Core Registers (CONFIG, STATUS...)
	  ("DMA-OFFSET"  #x140) ;; DMA Registers
	  ("MEM-OFFSET"  #x180) ;; Mem protection registers
	  ("MESH-OFFSET" #x1c0) ;; Mesh Config registers
	)
  )
)

(define-enum
  (name e-scr-set-mask)
  (comment "mask for sticky bits in special core registers")
  ;;(attrs)
  (prefix H-SCR-MASK-)
  (values
    (
	  ("STATUS"   #xfff0)
	)
  )
)


; General Register keyword names.
(define-keyword
  (name gr-names)
  (enum-prefix H-GPR-REGS-)
  (name-prefix "")
  (values
; some preferred aliases
   (sp 13) (lr 14) (fp 15)
; the default register names
   (r0  0)  (r1  1)  (r2  2)  (r3  3)  (r4  4)  (r5  5)  (r6  6)  (r7  7)
   (r8  8)  (r9  9) (r10 10) (r11 11) (r12 12) (r13 13) (r14 14) (r15 15)
   (r16 16) (r17 17) (r18 18) (r19 19) (r20 20) (r21 21) (r22 22) (r23 23)
   (r24 24) (r25 25) (r26 26) (r27 27) (r28 28) (r29 29) (r30 30) (r31 31)
   (r32 32) (r33 33) (r34 34) (r35 35) (r36 36) (r37 37) (r38 38) (r39 39)
   (r40 40) (r41 41) (r42 42) (r43 43) (r44 44) (r45 45) (r46 46) (r47 47)
   (r48 48) (r49 49) (r50 50) (r51 51) (r52 52) (r53 53) (r54 54) (r55 55)
   (r56 56) (r57 57) (r58 58) (r59 59) (r60 60) (r61 61) (r62 62) (r63 63)
; some less popular aliases
   (a1  0) (a2  1) (a3  2) (a4  3) (v1  4) (v2  5) (v3  6) (v4  7)
   (v5  8) (v6  9) (v7 10) (v8 11)
   (sb 9) (sl 10) (ip 12)
   )
  )

(define-normal-insn-enum post-index "+/- index register" () DIR_ f-addsubx (POSTINC POSTDEC))

(define-normal-insn-enum disp-post-modify "postmodify displacement" () PMOD_ f-pm (DISP POST))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					; Hardware pieces.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; All registers
;; All other registers are virtual.
;; Everything is routed through here to keep things in one place
;;
(define-hardware
  (name h-all-registers)
  (comment "all addressable registers")
  (type register SI (512))
  (indices extern-keyword all-reg-names)
  (attrs PROFILE)
  ;; Might want add mem barriers for set/get here.
  (set (index val)
	(sequence ()
	  (cond VOID
		((eq index (enum USI H-REG-SCR-CONFIG))
		  (c-call "epiphanybf_set_config" val)
		)
		((eq index (enum USI H-REG-SCR-STATUS))
		  (c-call "epiphanybf_set_status" val)
		)
		((eq index (enum USI H-REG-SCR-IMASK))
		  (c-call "epiphanybf_set_imask" val)
		)
		((eq index (enum USI H-REG-SCR-ILATST))
		  (c-call "epiphanybf_set_ilatst" val)
		)
		((eq index (enum USI H-REG-SCR-ILATCL))
		  (c-call "epiphanybf_set_ilatcl" val)
		)
		((eq index (enum USI H-REG-MESH-RESETCORE))
		  (c-call "epiphanybf_set_resetcore" val)
		)
		(else (set (raw-reg h-all-registers index) val))
	  )
	)
  )
)


;; 64 general-purpose registers
(define-hardware
  (name h-registers)
  (comment "General Purpose Registers")
  (type register SI (64))
  (attrs PROFILE VIRTUAL)
  (indices extern-keyword gr-names)
  ;; Forward get/set to h-all-registers handlers
  ;; Offset to GPR is 0 so we don't need to add anything to index.
  (get (index) (reg h-all-registers index))
  (set (index newval) (set (reg h-all-registers index) newval))
)

;; Same 64 registers as floating point registers
(define-hardware
  (name h-fpregisters)
  (comment "all GPRs as float values")
  (type register SF (64))
  (attrs PROFILE VIRTUAL)
  (indices extern-keyword gr-names)
  ;; Forward get/set to h-all-registers handlers
  ;; Offset to GPR is 0 so we don't need to add anything to index.
  (get (index) (subword SF (reg h-all-registers index) 0))
  (set (index newval) (set (reg h-all-registers index) (subword SI newval 0)))
)


(define-enum
  (name e-scr-status-bits)
  (comment "core status bits")
  ;;(attrs)
  (prefix H-SCR-STATUS-)
  (values
    (
	  ("CAIBIT"         0)
	  ("GIDISABLEBIT"   1)
	  ("KMBIT"          2) ;; UNDOCUMENTED/RESERVED
	  ("SFLAGBIT"       3) ;; UNDOCUMENTED/RESERVED
	  ("ZBIT"           4)
	  ("NBIT"           5)
	  ("CBIT"           6)
	  ("VBIT"           7)
	  ("BZBIT"          8)
	  ("BNBIT"          9)
	  ("BVBIT"         10)
	  ("BCBIT"         11) ;; UNDOCUMENTED/RESERVED
	  ("VSBIT"         12)
	  ("BISBIT"        13)
	  ("BVSBIT"        14)
	  ("BUSBIT"        15)
	  ("EXCAUSE0BIT"   16)
	  ("EXCAUSE1BIT"   17)
	  ("EXCAUSE2BIT"   18)
	  ("EXCAUSE3BIT"   19) ;; UNDOCUMENTED/RESERVED
	  ("BIT20"         20) ;; UNDOCUMENTED/RESERVED
	  ("BIT21"         21) ;; UNDOCUMENTED/RESERVED
	  ("BIT22"         22) ;; UNDOCUMENTED/RESERVED
	  ("BIT23"         23) ;; UNDOCUMENTED/RESERVED
	  ("BIT24"         24) ;; UNDOCUMENTED/RESERVED
	  ("BIT25"         25) ;; UNDOCUMENTED/RESERVED
	  ("BIT26"         26) ;; UNDOCUMENTED/RESERVED
	  ("BIT27"         27) ;; UNDOCUMENTED/RESERVED
	  ("BIT28"         28) ;; UNDOCUMENTED/RESERVED
	  ("BIT29"         29) ;; UNDOCUMENTED/RESERVED
	  ("BIT30"         30) ;; UNDOCUMENTED/RESERVED
	  ("BIT31"         31) ;; UNDOCUMENTED/RESERVED
	)
  )
)

;; Exception cause bits, different for Epiphany-III and Epiphany-IV
;; Use the Epiphany-III values for now.
;; TODO: Have separate machs for Epiphany-III and Epiphany-IV
(define-enum
  (name e-excause)
  (comment "Epiphany-III exception cause")
  (prefix H-SCR-STATUS-EXCAUSE-)
  ;;(attrs (MACH epiphanymf-3))
  (values
	(
	  ("UNIMPLEMENTED" 4)
	  ("SWI"           1)
	  ("UNALIGNED"     2)
	  ("ILLEGAL"       5)
	  ("FPU"           3)
	)
  )
)

;; Epiphany-IV exception causes
;;(define-enum
;;  (name e-excause)
;;  (comment "Epiphany-IV exception cause")
;;  (prefix H-SCR-STATUS-EXCAUSE)
;;  ;;(attrs (MACH epiphanymf-4))
;;  (values
;;	(
;;	  ("UNIMPLEMENTED" 15)
;;	  ("SWI"           14)
;;	  ("UNALIGNED"     13)
;;	  ("ILLEGAL"       12)
;;	  ("FPU"            7)
;;	)
;;  )
;;)

(define-enum
  (name e-scr-config-bits)
  (comment "core config bits")
  ;;(attrs)
  (prefix H-SCR-CONFIG-)
  (values
    (
	  ("TRMBIT"               0)
	  ("INVEXCENBIT"          1)
	  ("OVFEXCENBIT"          2)
	  ("UNEXCENBIT"           3)
	  ("TIMER0BIT0"           4)
	  ("TIMER0BIT1"           5)
	  ("TIMER0BIT2"           6)
	  ("TIMER0BIT3"           7)
	  ("TIMER1BIT0"           8)
	  ("TIMER1BIT1"           9)
	  ("TIMER1BIT2"          10)
	  ("TIMER1BIT3"          11)
	  ("MESHROUTEBIT0"       12) ;; UNDOCUMENTED/RESERVED
	  ("MESHROUTEBIT1"       13) ;; UNDOCUMENTED/RESERVED
	  ("MESHROUTEBIT3"       14) ;; UNDOCUMENTED/RESERVED
	  ("MESHROUTEBIT4"       15) ;; UNDOCUMENTED/RESERVED
	  ("SPLITBIT"            16) ;; UNDOCUMENTED/RESERVED
	  ("ARITHMETIC-MODEBIT0" 17)
	  ("ARITHMETIC-MODEBIT1" 18)
	  ("ARITHMETIC-MODEBIT2" 19)
	  ("EMULMODEBIT"         20) ;; UNDOCUMENTED/RESERVED
	  ("SINGLEISSUEBIT"      21) ;; UNDOCUMENTED/RESERVED
	  ("CLOCKGATEENBIT"      22)
	  ("MBKPTENBIT"          23)
	  ("CORECONFIGBIT24"     24)
	  ("CORECONFIGBIT25"     25)
	  ("CORECONFIGBIT26"     26)
	  ("CORECONFIGBIT27"     27)
	  ("CLOCKDIVBIT0"        28) ;; UNDOCUMENTED/RESERVED
	  ("CLOCKDIVBIT1"        29) ;; UNDOCUMENTED/RESERVED
	  ("CLOCKDIVBIT2"        30) ;; UNDOCUMENTED/RESERVED
	  ("CLOCKDIVBIT3"        31) ;; UNDOCUMENTED/RESERVED
	)
  )
)

(define-enum
  (name e-dma-config-bits)
  (comment "dma config bits")
  ;;(attrs)
  (prefix H-DMA-CONFIG-)
  (values
    (
	  (ENABLEBIT        0)
	  (MASTERBIT        1)
	  (CHAINMODEBIT     2)
	  (STARTUPBIT       3)
	  (IRQENBIT         4)
	  (DATASIZEBIT0     5)
	  (DATASIZEBIT1     6)
	  ;; [15:7]  reserved
	  ;; [31:16] next dma descriptor pointer
	)
  )
)

(define-enum
  (name e-dma-status-bits)
  (comment "dma status bits")
  ;;(attrs)
  (prefix H-DMA-STATUS-)
  (values
    (
	  (DMASTATEBIT0        0)
	  (DMASTATEBIT1        1)
	  (DMASTATEBIT2        2)
	  (DMASTATEBIT3        3)
	  ;; [15:4]  reserved
	  ;; [31:16] current dma descriptor pointer
	)
  )
)

;; Special registers - accessed via MOVTS and MOVFS.
;;
;;  "Core control and status" in group MR0=0, MR1=0

(define-keyword
  (name cr-names)
  (enum-prefix H-CORE-REGISTERS-)
  (name-prefix "")
  (values
	(config       0)
	(status       1) ; unified condition codes
	(pc           2) ; virtualized PC
	(debugstatus  3) ;
	(iab          4)
	(lc           5) ;loop counter            Not impemented
	(ls           6) ;loop start address      Not impemented
	(le           7) ;loop end address        Not impemented
	(iret         8)
	(imask        9)
	(ilat        10)
	(ilatst      11)
	(ilatcl      12)
	(ipend       13)
	(ctimer0     14)
	(ctimer1     15)
	(fstatus     16)
  )
)
;; DMA registers in group MR0=1, MR1=0

(define-keyword
  (name crdma-names)
  (enum-prefix H-COREDMA-REGISTERS-)
  (name-prefix "")
  (values
	(dma0config     0)
	(dma0stride     1)
	(dma0count      2)

	(dma0srcaddr    3)
	(dma0dstaddr    4)

	(dma0auto0      5)
	(dma0auto1      6)

	(dma0status     7)

	(dma1config     8)
	(dma1stride     9)
	(dma1count      10)

	(dma1srcaddr    11)
	(dma1dstaddr    12)

	(dma1auto0      13)
	(dma1auto1      14)

	(dma1status     15)
  )
)
;; mem configuration registers in group MR0=0, MR1=1

(define-keyword
  (name crmem-names)
  (enum-prefix H-COREMEM-REGISTERS-)
  (name-prefix "")
  (values
	(memconfig     0)
	(memstatus     1)
	(memprotect    2)
	(memreserve    3)
  )
)

;; mesh configuration registers in group MR0=1, MR1=1

(define-keyword
  (name crmesh-names)
  (enum-prefix H-COREMESH-REGISTERS-)
  (name-prefix "")
  (values
	(meshconfig    0)
	(coreid        1)
	(meshmulticast 2)
	(resetcore     3)
  )
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					; PC is a byte-addressed register
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define-hardware
  (name h-pc)
  (comment "program counter")
  (type pc)
  (attrs PC PROFILE VIRTUAL)
  ;; Forward get/set to h-all-registers handlers
  (get () (reg h-all-registers (enum USI H-REG-SCR-PC)))
  (set (newval) (set (reg h-all-registers (enum USI H-REG-SCR-PC)) newval))
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					; Memory Effective Address wants to be visible
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(dnh h-memaddr "memory effective address" (PROFILE) (register SI) () () ())
(dnop memaddr  "memory effective address" (SEM-ONLY) h-memaddr f-nil)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					; Special Core Registers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; STATUS
;; [0]=core active indicator
;; [1]=global interrupt disable
;; [2]=processor mode(1=user mode, 0=kernel mode)
;; [3]=wired AND global flag

;; [4]=integer zero                        zbit
;; [5]=integer negative                    nbit
;; [6]=integer carry                       cbit
;; [7]=integer overflow                    vbit

;; [8]=fpu zero flag                       bzbit
;; [9]=fpu negative flag                   bnbit
;; [10]=fpu overflow flag                  bvbit
;; [11]=fpu carry flag(not used)           bcbit

;; [12]=ialu overflow flag(sticky)         vsbit
;; [13]=fpu invalid flag(sticky)           bisbit
;; [14]=fpu overflow flag(sticky)          bvsbit
;; [15]=fpu underflow flag(sticky)         busbit

;; [17:16]=exception cause 00=no exception 01=load-store exception 10=fpu exception 11=unimplemented instruction
;;                                         excause1bit
;;                                         excause0bit

;; [18]=external load stalled              excause2bit
;; [19]=external fetch stalled             extFstallbit

;; [31:20]=RESERVED





(define-hardware
  (name h-core-registers)
  (comment "Special Core Registers")
  (type register USI (17))
  (attrs VIRTUAL)
  (indices extern-keyword cr-names)
  ;; Forward get/set to h-all-registers handlers
  (get (index)
	(reg h-all-registers (add USI (enum USI H-REG-GRP-SCR-OFFSET) index))
  )
  (set (index val)
	(set (reg h-all-registers (add USI (enum USI H-REG-GRP-SCR-OFFSET) index))
		  val)
  )
)
					; (define-pmacro (hcr-config) (reg h-core-registers 0)) etc.
(%splice begin (%unsplice (%map
			   (%pmacro (xname xnum)
				    ;;(define-pmacro ((%sym hcr- xname)) (reg h-core-registers xnum)))
					;;(dnop name cmt (SEM-ONLY) hname f-nil)
				    (define-pmacro ((%sym hcr- xname)) (reg h-core-registers xnum)))

			   (
			    config
			    status
			    pc
			    debugstatus
			    iab
			    lc
			    ls
			    le
			    iret
			    imask
			    ilat
			    ilatst
			    ilatcl
			    ipend
			    ctimer0
			    ctimer1
			    hstatus



			    )

			   (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
			      )
			   )))

; Define hardware and operands for each of the physical bits in STATUS &
; CONFIG registers
(define-pmacro (psw-bit Name Cmt Regidx Prefix)
  (%let (
	  (h-name (%sym "h-" Name))
	  (bitidx    (%sym (%upcase (%str Prefix Name))))
	  (operand (reg h-all-registers Regidx))
    )
    (begin
	  (define-hardware
		(name h-name)
		(comment Cmt)
		(attrs VIRTUAL)
		(type register BI)
		(get ()
		  (
			sequence ((USI regval) (USI bitval))
			  (set regval operand)
			  (set bitval (and (srl regval bitidx) 1))
			  (trunc BI bitval)
		  )
		)
		(set (newval)
		  ;; Set reg bit without interfering with other bits
		  (c-raw-call VOID "SET_REG_BIT_ATOMIC" Regidx (enum USI bitidx) newval)
		)
	  )
	  (dnop Name cmt (SEM-ONLY) h-name f-nil)
	)
  )
)

(define-pmacro (psw-bit-cr-status Name Cmt)
  (psw-bit Name Cmt (enum H-REG-SCR-STATUS) H-SCR-STATUS-)
)
(define-pmacro (psw-bit-cr-config Name Cmt)
  (psw-bit Name Cmt (enum H-REG-SCR-CONFIG) H-SCR-CONFIG-)
)
;; Operands for status bits
(psw-bit-cr-status caibit       "core active indicator mode bit" ) ;;  0
(psw-bit-cr-status gidisablebit "global interrupt disable bit"   ) ;;  1
(psw-bit-cr-status kmbit        "kernel mode bit"                ) ;;  2
(psw-bit-cr-status sflagbit     "sflag bit"                      ) ;;  3
(psw-bit-cr-status zbit         "integer zero bit"               ) ;;  4
(psw-bit-cr-status nbit         "integer neg bit"                ) ;;  5
(psw-bit-cr-status cbit         "integer carry bit"              ) ;;  6
(psw-bit-cr-status vbit         "integer overflow bit"           ) ;;  7
(psw-bit-cr-status bzbit        "floating point zero bit"        ) ;;  8
(psw-bit-cr-status bnbit        "floating point neg bit"         ) ;;  9
(psw-bit-cr-status bvbit        "floating point ovfl bit"        ) ;; 10
(psw-bit-cr-status bcbit        "floating point carry bit"       ) ;; 11
(psw-bit-cr-status vsbit        "integer overflow sticky"        ) ;; 12
(psw-bit-cr-status bisbit       "floating point invalid sticky"  ) ;; 13
(psw-bit-cr-status bvsbit       "floating point overflow sticky" ) ;; 14
(psw-bit-cr-status busbit       "floating point underflow sticky") ;; 15
(psw-bit-cr-status excause0bit  "exception cause bit0"           ) ;; 16
(psw-bit-cr-status excause1bit  "exception cause bit1"           ) ;; 17
(psw-bit-cr-status excause2bit  "exception cause bit2"           ) ;; 18
(psw-bit-cr-status excause3bit  "exception cause bit3"           ) ;; 19

;; Excause operand
(define-hardware
  (name h-scr-status-excause)
  (comment "Exception cause bits in status register")
  (type register UQI) ;; Not really, just 4 bits
  (attrs VIRTUAL)
  ;; Forward get/set to h-all-registers handlers
  (get ()
	(sequence ((USI status))
	   (set status (reg h-all-registers (enum USI H-REG-SCR-STATUS)))
	   (and (srl status H-SCR-STATUS-EXCAUSE0BIT) #xf)
	)
  )
  ;; Two steps: clear bits, then set value
  (set (newval)
	(sequence ((USI mask) (USI shifted))
	  (set mask #xfff0ffff)  ;; bit 16-19
	  (set shifted (sll (and newval #xf) (enum USI H-SCR-STATUS-EXCAUSE0BIT)))
	  (c-raw-call VOID "AND_REG_ATOMIC"  (enum USI H-REG-SCR-STATUS) mask)
	  (c-raw-call VOID "OR_REG_ATOMIC"   (enum USI H-REG-SCR-STATUS) shifted)
	)
  )
)

;; Operands for config bits
(psw-bit-cr-config trmbit              "0=round to nearest, 1=truncate select bit")
(psw-bit-cr-config invexcenbit         "invalid exception enable bit"   )
(psw-bit-cr-config ovfexcenbit         "overflow exception enable bit"  )
(psw-bit-cr-config unexcenbit          "underflow exception enablebit"  )

(psw-bit-cr-config timer0bit0          "timer 0 mode selection 0"       )
(psw-bit-cr-config timer0bit1          "timer 0 mode selection 1"       )
(psw-bit-cr-config timer0bit2          "timer 0 mode selection 2"       )
(psw-bit-cr-config timer0bit3          "timer 0 mode selection 3"       )
(psw-bit-cr-config timer1bit0          "timer 1 mode selection 0"       )
(psw-bit-cr-config timer1bit1          "timer 1 mode selection 1"       )
(psw-bit-cr-config timer1bit2          "timer 1 mode selection 2"       )
(psw-bit-cr-config timer1bit3          "timer 1 mode selection 3"       )

(psw-bit-cr-config arithmetic-modebit0 "arithmetic mode bit0"           )
(psw-bit-cr-config arithmetic-modebit1 "arithmetic mode bit1"           )
(psw-bit-cr-config arithmetic-modebit2 "arithmetic mode bit2"           )

(psw-bit-cr-config clockgateenbit      "clock gating enable bkpt enable")
(psw-bit-cr-config mbkptenbit          "multicore bkpt enable"          )


;; DMA registers in MMR space
(define-hardware
  (name h-coredma-registers)
  (comment "DMA registers in MMR space")
  (type register USI (16))
  (attrs VIRTUAL)
  (indices extern-keyword crdma-names)
  ;; Forward get/set to h-all-registers handlers
  (get (index)
	(reg h-all-registers (add USI (enum USI H-REG-GRP-DMA-OFFSET) index))
  )
  (set (index val)
	(set (reg h-all-registers (add USI (enum USI H-REG-GRP-DMA-OFFSET) index))
		  val)
  )
)

;; MEM registers in MMR space
(define-hardware
  (name h-coremem-registers)
  (comment "MEM registers in MMR space")
  (type register USI (4))
  (attrs VIRTUAL) ;; ?? PROFILE ??
  (indices extern-keyword crmem-names)
  (get (index)
	(reg h-all-registers (add USI (enum USI H-REG-GRP-MEM-OFFSET) index))
  )
  (set (index val)
	(set (reg h-all-registers (add USI (enum USI H-REG-GRP-MEM-OFFSET) index))
		  val)
  )
)

;; MEM registers in MMR space
(define-hardware
  (name h-coremesh-registers)
  (comment "MESH registers in MMR space")
  (type register USI (4))
  (attrs VIRTUAL) ;; ?PROFILE?
  (indices extern-keyword crmesh-names)
  (get (index)
	(reg h-all-registers (add USI (enum USI H-REG-GRP-MESH-OFFSET) index))
  )
  (set (index val)
	(set (reg h-all-registers (add USI (enum USI H-REG-GRP-MESH-OFFSET) index))
		  val)
  )
)

					; Operands

					; Branch displacements
(define-operand
  (name simm24)
  (comment "branch address pc-relative")
  (attrs RELAX)
  (type h-iaddr)
  (index f-simm24)
  (handlers (parse "branch_addr")))

(define-operand
  (name simm8)
  (comment "branch address pc-relative")
  (attrs RELAX)
  (type h-iaddr)
  (index f-simm8)
  (handlers (parse "branch_addr")))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					; Register operands
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define-pmacro (short-regs nm group hw cmt)
  (define-operand
    (name nm)
    (comment cmt)
    (attrs)
    (type hw)
    (index (%sym "f-r" group))
    (handlers (parse "shortregs") (print "keyword"))
    )
  )

(define-pmacro (short-regs-core nm group hw cmt)
  (define-operand
    (name nm)
    (comment cmt)
    (attrs)
    (type hw)
    (index (%sym "f-s" group))
    (handlers (parse "shortregs") (print "keyword"))
    )
  )


					; short regs (0-7)
(short-regs rd d h-registers "destination register")
(short-regs rn n h-registers "source register")
(short-regs rm m h-registers "source register")

(short-regs frd d h-fpregisters "fp destination register")
(short-regs frn n h-fpregisters "fp source register")
(short-regs frm m h-fpregisters "fp source register")

					; long regs (0-63)
(dnop rd6 "destination register" () h-registers f-rd6)
(dnop rn6 "source register"      () h-registers f-rn6)
(dnop rm6 "source register"      () h-registers f-rm6)

(dnop frd6 "fp destination register" () h-fpregisters f-rd6)
(dnop frn6 "fp source register"      () h-fpregisters f-rn6)
(dnop frm6 "fp source register"      () h-fpregisters f-rm6)

					; special regs (0-7)
(short-regs-core sd d h-core-registers "special destination")
(short-regs-core sn n h-core-registers "special source")

					; special regs (long form)
(dnop sd6 "special destination register" () h-core-registers f-sd6)
(dnop sn6 "special source register"      () h-core-registers f-sn6)

(dnop sddma "dma register" () h-coredma-registers f-sd6)
(dnop sndma "dma register"      () h-coredma-registers f-sn6)
(dnop sdmem "mem register" () h-coremem-registers f-sd6)
(dnop snmem "mem register"      () h-coremem-registers f-sn6)
(dnop sdmesh "mesh register" () h-coremesh-registers f-sd6)
(dnop snmesh "mesh register"      () h-coremesh-registers f-sn6)

					; Immediate literals - but don't allow register names!
(define-pmacro (dimmop nm cmt hwtype idx)
  (define-operand (name nm) (comment cmt) (type hwtype) (index idx)
    (attrs RELAX)
    (handlers (parse "simm_not_reg")
	      (print "simm_not_reg")))
  )

(dimmop simm3   "signed 3-bit literal"    h-sint f-sdisp3)
(dimmop simm11  "signed 11-bit literal"   h-sint f-sdisp11)
(dnop disp3  "short data displacement"   () h-uint f-disp3)
(dnop trapnum6 "parameter for swi or trap" () h-uint f-trap-num)

(define-pmacro (duimmop nm cmt hwtype idx)
  (define-operand (name nm) (comment cmt) (type hwtype) (index idx)
    (attrs)
    (handlers (parse "uimm_not_reg")
	      (print "uimm_not_reg")))
  )

(duimmop swi_num "unsigned 6-bit swi#" h-uint f-trap-num)
(duimmop disp11 "sign-magnitude data displacement" h-uint f-disp11)

(dnop shift   "immediate shift amount"   () h-uint f-shift)

(define-operand (name imm16) (comment "16-bit unsigned literal") (attrs RELAX)
  (type h-addr) (index f-imm16) (handlers (parse "imm16")))
(define-operand (name imm8) (comment "8-bit unsigned literal") (attrs RELAX)
  (type h-addr) (index f-imm8) (handlers (parse "imm8")))

(define-operand
  (name direction)
  (comment "+/- indexing")
  (attrs)
  (type h-uint)
  (index f-addsubx)
  (handlers (parse "postindex")
	    (print "postindex")))

(define-operand
  (name dpmi)
  (comment "+/- magnitude immediate displacement")
  (attrs)
  (type h-uint)
  (index f-subd)
  (handlers (parse "postindex")
	    (print "postindex")))



;; call exception macro - no check for imask
(define-pmacro (schedule-exception reason)
  (sequence ()
	(set (reg h-scr-status-excause) reason) ;; STATUS bits alias.
	(set (hcr-ilatst) 2) ;; Exception interrupt bit
  )
)


;;      (lc             5);loop counter            Not impemented
;;       (ls             6);loop start address      Not impemented
;;       (le             7);loop end address        Not impemented

;;have callback to adjust pc in case od events ( HW loops ... )
(define-pmacro (dni_wrapper isnid stdrdesc attr_ strassembl iopcode proceed null_b)
  (begin
    (dni isnid stdrdesc attr_ strassembl iopcode
	 (sequence () proceed
		   (sequence ((USI tmpPC))
			     ;;(set tmpPC  (c-call  USI "epiphany_post_isn_callback" pc))

			     (if (eq pc (hcr-le))
				 (set (hcr-lc) (sub (hcr-lc) #x1)))
			     (if (and
				   (eq pc (hcr-le))
				   (not (eq (hcr-lc) #x0)))
				 (set pc (hcr-ls)))
			     )
		   )
	 null_b)
    )
  )





;; Some handy macros
;;

;; define instructions
;;   Short (16 bit forms) must appear first so that instruction
;;   selection can reject them and match long forms when registers
;;   or immediates exceed the values in the 16 bit instructions


;; B<COND> SIMM8
;; B<COND> SIMM24

(define-pmacro (br-insn name cond g-op)
  (begin
					; the 16-bit versions of branch
    (dni (%sym "b" name "16")
	 (%str "Conditional Branch - 16 bit" name)
	 (COND-CTI SHORT-INSN)
	 (%str "b" name ".s $simm8")
	 (+ OP4_BRANCH16 (%sym "OPC_" cond) simm8)
	 (if (g-op)
	     (set pc simm8)
	     )
	 ()
	 )

    (dnmi (%sym "b" name "16r") "relaxable conditional branch"
	  (COND-CTI RELAXABLE)
	  (%str "b" name " $simm8")
	  (emit (%sym "b" name "16") simm8)
	  )

    (dni (%sym "b" name)
	 (%str "Conditional Branch " name)
	 (COND-CTI)
	 (%str "b" name ".l $simm24")
	 (+ OP4_BRANCH (%sym "OPC_" cond) simm24)
	 (if (g-op)
	     (set pc simm24)
	     )
	 ()
	 )

    (dnmi (%sym "b" name "32r") "relaxable conditional branch"
	  (COND-CTI RELAXED)
	  (%str "b" name " $simm24")
	  (emit (%sym "b" name) simm24)
	  )
    )
  )


					; basic conditional branches for integer arithmetic
(br-insn "eq"	 EQ	(%pmacro () (eq zbit #x1)))
(br-insn "ne"	 NE	(%pmacro () (eq zbit #x0)))
(br-insn "gtu"   GTU	(%pmacro () (and BI cbit (not BI zbit))))
(br-insn "gteu"  GTEU	(%pmacro () (eq cbit #x1)))
(br-insn "lteu"  LTEU	(%pmacro () (or BI (not BI cbit) zbit)))
(br-insn "ltu"   LTU	(%pmacro () (eq cbit #x0)))
(br-insn "gt"	 GT	(%pmacro () (and BI (not BI zbit) (eq vbit nbit))))
(br-insn "gte"   GTE	(%pmacro () (eq vbit nbit)))
(br-insn "lt"	 LT	(%pmacro () (xor BI vbit nbit)))
(br-insn "lte"   LTE	(%pmacro () (or BI zbit (xor vbit nbit))))


					; floating point condition codes (floating point instructions)
(br-insn "beq"   BEQ    (%pmacro () (or BI bzbit bzbit)))
(br-insn "bne"   BNE    (%pmacro () (not BI bzbit)))
(br-insn "blt"   BLT    (%pmacro () (and BI bnbit (not bzbit))))
(br-insn "blte"  BLTE   (%pmacro () (or BI bnbit bzbit)))

					; unconditional branches
(dni b16 "short unconditional branch" (UNCOND-CTI SHORT-INSN)
     "b.s $simm8"
     (+ OP4_BRANCH16 OPC_B simm8)
     (set pc simm8)
     ()
     )

(dnmi b16r "relaxable b16"
      (UNCOND-CTI RELAXABLE)
      "b $simm8"
      (emit b16 simm8)
      )

(dni b "long unconditional branch" (UNCOND-CTI)
     "b.l $simm24"
     (+ OP4_BRANCH OPC_B simm24)
     (set pc simm24)
     ()
     )

(dnmi b32r "relaxable b"
      (UNCOND-CTI RELAXED)
      "b $simm24"
      (emit b simm24))

;; BL R,ADDR

(dni bl16 "branch and link"
     (UNCOND-CTI SHORT-INSN)
     ("bl.s $simm8")
     (+ OP4_BRANCH16 OPC_BL simm8)
     (sequence ()
	       (set (reg h-registers 14) (add pc (const 2)))
	       (set pc simm8))
     ()
     )

(dnmi bl16r "bl16 relaxable"
      (UNCOND-CTI RELAXABLE)
      "bl $simm8"
      (emit bl16 simm8))

(dni bl "branch and link"
     (UNCOND-CTI)
     ("bl.l $simm24")
     (+ OP4_BRANCH OPC_BL simm24)
     (sequence ()
	       (set (reg h-registers 14) (add pc (const 4)))
	       (set pc simm24))
     ()
     )

(dnmi blr "bl relaxable"
      (UNCOND-CTI RELAXED)
      "bl $simm24"
      (emit bl simm24))

;; JUMP <RN>
(dni jr16 "unconditional jump 16"
     (UNCOND-CTI SHORT-INSN)
     ("jr $rn")
     (+ OP4_FLOW16 (f-opc-8-5 #x14) (f-dc-15-3 #x0) (f-dc-9-1 #x0) rn)
     (set pc rn)
     ()
     )

;; RTS / JR
;; ??? Putting a constant into a multi-ifield does not work -
;; the constant gets inserted in full into each part.
					;(dnmi rts "return from subroutine"
					;     (UNCOND-CTI)
					;     ("rts")
					;     (emit jr (rn6 14)) ; jr lr  / jr r14
					;)
;; RTS / JR
(dni rts "return from subroutine"
     (ALIAS UNCOND-CTI)
     ("rts")
     (+ OP4_MISC (f-opc-8-5 #x14) (f-opc-19-4 #x2) (f-rn 6) (f-rn-x 1)
	(f-dc-9-1 #x0)
	(f-dc-15-3 #x0)
	(f-dc-25-6 #x0)
	(f-dc-31-3 #x0)
	)
     (set pc (reg h-registers 14))
     ()
     )

(dni jr "unconditional jump"
     (UNCOND-CTI)
     ("jr $rn6")
     (+ OP4_MISC (f-opc-8-5 #x14) (f-opc-19-4 #x2) rn6
	(f-dc-9-1 #x0)
	(f-dc-15-3 #x0)
	(f-dc-25-6 #x0)
	(f-dc-31-3 #x0)
	)
     (set pc rn6)
     ()
     )


;; JALR <RN>
(dni jalr16 "jump and link register"
     (UNCOND-CTI SHORT-INSN)
     ("jalr $rn")
     (+ OP4_FLOW16  (f-opc-8-5 #x15) (f-dc-15-3 #x0) (f-dc-9-1 #x0)  rn)
     (sequence ()
	       (set (reg h-registers 14) (add pc (const 2)))
	       (set pc rn)
	       )
     ()
     )

(dni jalr "jump and link register"
     (UNCOND-CTI)
     ("jalr $rn6")
     (+ OP4_MISC
	(f-opc-8-5 #x15)
	(f-opc-19-4 #x2)
	rn6
	(f-dc-9-1 #x0)
	(f-dc-15-3 #x0)
	(f-dc-25-6 #x0)
	(f-dc-31-3 #x0)

	)
     (sequence ()
	       (set (reg h-registers 14) (add pc (const 4)))
	       (set pc rn6))
     ()
     )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;  Load/Store Memory Instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(define-pmacro (callMisalignmentExceptionIfNeeded sel  addr isAlignmentAccess)
  (sequence ((BI scale))
    (set isAlignmentAccess
	 (case BI sel
	   ((OPW_BYTE)	(eq (and addr #x0) #x0))
	   ((OPW_SHORT)	(eq (and addr #x1) #x0))
	   ((OPW_WORD)	(eq (and addr #x3) #x0))
	   (else	(eq (and addr #x7) #x0))))
    (if (not BI isAlignmentAccess)
	  (schedule-exception (enum USI H-SCR-STATUS-EXCAUSE-UNALIGNED))
	)
  )
)



;; helper to convert size selector OPW_<mode> into a literal scale factor
(define-pmacro (ConvertSelectorToShift sel scale)
  (set scale
       (case SI sel
	 ((OPW_BYTE)	(const 0))
	 ((OPW_SHORT)	(const 1))
	 ((OPW_WORD)	(const 2))
	 (else	(const 3))))
)

;; common load macros from effective address, handling 8/16/32/64 bits
(define-pmacro (load-double-from-ea regnum eff-addr mode sel)
  (sequence ((SI loadaddr) (BI isAlignmentAccess))
	    (set loadaddr eff-addr)
	    (callMisalignmentExceptionIfNeeded sel  loadaddr isAlignmentAccess)

	    (if (not (not BI isAlignmentAccess))
		(sequence ()
			  (set memaddr loadaddr)
			  (set regnum (mem SI loadaddr))
			  (set loadaddr (add loadaddr (const 4)))
			  (set memaddr loadaddr)
			  (set (reg h-registers
				    (add (index-of regnum)
					 (const 1)))
			       (mem SI loadaddr))

			  )
		)
	    )
  )

(define-pmacro (load-from-ea regnum eff-addr mode sel)
  (sequence ((BI isAlignmentAccess))

	    (callMisalignmentExceptionIfNeeded sel eff-addr   isAlignmentAccess)
	    (if (not (not BI isAlignmentAccess))
		(sequence ()
			  (set memaddr eff-addr)
			  (set regnum (zext SI (mem mode eff-addr)))
			  )
		)
	    )
  ) ;; 8/16/32 bit cases


;; common store to effective address, handling 8/16/32/64 bit data
(define-pmacro (store-double-to-ea eff-addr regnum mode sel)
  (sequence ((SI storeaddr) (BI isAlignmentAccess))
	    (set storeaddr eff-addr)
	    (callMisalignmentExceptionIfNeeded sel storeaddr isAlignmentAccess)
	    (if (not (not BI isAlignmentAccess))
		(sequence ()
			  (set memaddr storeaddr)
			  (set (mem SI storeaddr) regnum)
			  (set storeaddr (add storeaddr (const 4)))
			  (set memaddr storeaddr)
			  (set (mem SI storeaddr)
			       (reg h-registers (add (index-of regnum) (const 1))))
			  )
		)
	    )
  )

(define-pmacro (store-to-ea eff-addr regnum mode sel)
  (sequence ((BI isAlignmentAccess))
	    (callMisalignmentExceptionIfNeeded sel eff-addr   isAlignmentAccess)
	    (if (not (not BI isAlignmentAccess))
		(sequence ()
			  (set memaddr eff-addr)
			  (set (mem mode eff-addr) regnum)
			  )
		)
	    )
  )	;8/16/32 bit cases


(define-pmacro (load-insn name mode sel sem-op)
  (begin
    (dni_wrapper (%sym name "x16.s")
		 (%str "load " mode " indexed")
		 (SHORT-INSN)
		 (%str name " $rd,[$rn,$rm]")
		 (+ OP4_LDSTR16X sel OP_LOAD rd rn rm)
		 (sequence ()
			   (sem-op rd (add rn rm) mode sel))
		 ()
		 )


    (dni_wrapper (%sym name "p16.s")
		 (%str "load " mode " postmodify")
		 (SHORT-INSN)
		 (%str name " $rd,[$rn],$rm")
		 (+ OP4_LDSTR16P sel OP_LOAD rd rn rm)
		 (sequence ((SI tmprm))
			   (set tmprm rm)
			   (sem-op rd rn mode sel)
			   (set rn (add rn tmprm)))
		 ()
		 )


    (dni_wrapper (%sym name "x.l")
		 (%str "load " mode " indexed")
		 ()
		 (%str name " $rd6,[$rn6,$direction$rm6]")
		 (+ OP4_LDSTRX sel OP_LOAD (f-opc-19-4 #x0) (f-dc-22-1 #x0) (f-dc-21-1 #x0) rd6 rn6 direction rm6)
		 (sequence ()
			   (if (ifield f-addsubx)
			       (sem-op rd6 (sub rn6 rm6) mode sel)
			       (sem-op rd6 (add rn6 rm6) mode sel)))
		 ()
		 )

    (dnmi (%sym name "x")
	  (%str "load " mode " indexed")
	  (NO-DIS)
	  (%str name ".l $rd6,[$rn6,$direction$rm6]")
	  (emit  (%sym name "x.l") rd6 rn6 direction rm6)
	  )



    (dni_wrapper (%sym name "p.l")
		 (%str "load " mode " postmodify")
		 ()
		 (%str name " $rd6,[$rn6],$direction$rm6")
		 (+ OP4_LDSTRP sel OP_LOAD (f-opc-19-4 #x0) (f-dc-22-2 #x0) rd6 rn6 direction rm6)
		 (sequence ((SI tmprm))
			   (set tmprm rm6)
			   (sem-op rd6 rn6 mode sel)
			   (if (ifield f-addsubx)
			       (set rn6 (sub rn6 tmprm))
			       (set rn6 (add rn6 tmprm)))
			   )
		 ()
		 )


    (dnmi (%sym name "p")
	  (%str "load " mode " postmodify")
	  (NO-DIS)
	  (%str name ".l $rd6,[$rn6],$direction$rm6")
	  (emit  (%sym name "p.l") rd6 rn6 direction rm6)
	  )


    ;;immediate modes last so reg forms found first.
    (dni_wrapper (%sym name "d16.s")
		 (%str "load " mode " displacement")
		 (SHORT-INSN IMM3)
		 (%str name " $rd,[$rn,$disp3]")
		 (+ OP4_LDSTR16D sel OP_LOAD rd rn disp3) ;; convert size to 'B'
		 (sequence ((SI effa)
			    (SI scale))
			   (ConvertSelectorToShift sel scale)
			   (set effa (add rn (sll disp3 scale)))
			   (sem-op rd effa mode sel)
			   )
		 ()
		 )


    (dni_wrapper (%sym name "d.l")
		 (%str "load " mode " displacement")
		 ()
		 (%str name " $rd6,[$rn6,$dpmi$disp11]")
		 (+ OP4_LDSTRD sel OP_LOAD PMOD_DISP rd6 rn6 dpmi disp11)
		 (sequence ((SI effa)
			    (SI scale))
			   (ConvertSelectorToShift sel scale)
			   (if dpmi
			       (set effa (sub rn6 (sll disp11 scale)))
			       (set effa (add rn6 (sll disp11 scale)))
			       )
			   (sem-op rd6 effa mode sel)
			   )
		 ()
		 )

    (dnmi (%sym name "d")
	  (%str "load " mode " displacement")
	  (NO-DIS)
	  (%str name ".l $rd6,[$rn6,$dpmi$disp11]")
	  (emit  (%sym name "d.l") rd6 rn6  dpmi disp11)
	  )



    (dni_wrapper (%sym name "dpm.l")
		 (%str "load " mode " displacement post-modify")
		 ()
		 (%str name " $rd6,[$rn6],$dpmi$disp11")
		 (+ OP4_LDSTRD sel OP_LOAD PMOD_POST rd6 rn6 dpmi disp11)
		 (sequence ((SI scale))
			   (ConvertSelectorToShift sel scale)
			   (sem-op rd6 rn6 mode sel)
			   (if dpmi
			       (set rn6 (sub rn6 (sll disp11 scale)))
			       (set rn6 (add rn6 (sll disp11 scale)))
			       )
			   )
		 ()
		 )

    (dnmi (%sym name "dpm")
	  (%str "load " mode " displacement post-modify")
	  (NO-DIS)
	  (%str name ".l $rd6,[$rn6],$dpmi$disp11")
	  (emit  (%sym name "dpm.l") rd6 rn6  dpmi disp11)
	  )


    ;; ;; macro form with a zero displacement
    (dnmi (%sym name "ds0") "load with 0 disp"
	  (SHORT-INSN IMM3)
	  (%str name " $rd,[$rn]")
	  (emit (%sym name "d16.s") rd rn (disp3 0))
	  )
    (dnmi (%sym name "dl0") "load with 0 disp"
    	  (NO-DIS)
	  (%str name " $rd6,[$rn6]")
	  (emit (%sym name "d.l") rd6 rn6 (dpmi 0) (disp11 0))
	  )
    (dnmi (%sym name "dl0.l") "load with 0 disp"
    	  (NO-DIS)
	  (%str name ".l $rd6,[$rn6]")
	  (emit (%sym name "d.l") rd6 rn6 (dpmi 0) (disp11 0))
	  )


    )
  )

(load-insn ldrb QI OPW_BYTE load-from-ea)
(load-insn ldrh HI OPW_SHORT load-from-ea)
(load-insn ldr  SI OPW_WORD  load-from-ea)
(load-insn ldrd DI OPW_DOUBLE load-double-from-ea)




;; TMP = MEM[RD+RM];    /* Copy content of memory to tmp.  */
;; if (~TMP)            /* Check if memory location is zero.  */
;;   MEM[RD+RM] = RD;   /* If zero, write RD to memory.  */
;; RD = TMP;            /* Always write tmp into RD (NOTE it's destructive).  */


(define-pmacro (testset-insn name mode sel)
  (%let
	( (c-fun (%str "epiphany_testset_" mode) ) )
	(begin
	  (dni_wrapper (%sym name "t")
		(%str "testset " mode " indexed")
		()
		(%str name " $rd6,[$rn6,$direction$rm6]")
		(+ OP4_LDSTRX sel OP_LOAD (f-opc-19-4 #x0) (f-dc-22-1 #x0) (f-dc-21-1 #x1)
		   rd6 rn6 direction rm6)
		(sequence ((SI eff-addr) (BI isAlignmentAccess))
		  (if (ifield f-addsubx)
			(set  eff-addr  (sub rn6 rm6))
			(set  eff-addr  (add rn6 rm6))
		  )
		  (callMisalignmentExceptionIfNeeded sel eff-addr isAlignmentAccess)
		  (if (not (not BI isAlignmentAccess))
			(set rd6 (c-call SI c-fun eff-addr rd6))
		  )
		)
		()
	  )

	  (dnmi  (%sym name "t.l")
		(%str "testset " mode ".l indexed")
		(NO-DIS)
		(%str name ".l $rd6,[$rn6,$direction$rm6]")
		(emit (%sym name "t") rd6 rn6 direction rm6)
	  )
	)
  )
)

(testset-insn testsetb QI OPW_BYTE)
(testset-insn testseth HI OPW_SHORT)
(testset-insn testset  SI OPW_WORD)
;;no double mode support, since we have to send the src address, data
;;(testset-insn testsetd DI OPW_DOUBLE load-double-from-ea)



;; need 16 bit forms too
(define-pmacro (store-insn name mode sel sem-op)
  (begin
    (dni_wrapper (%sym name "x16")
		 (%str "store" mode " indexed")
		 (SHORT-INSN)
		 (%str name " $rd,[$rn,$rm]")
		 (+ OP4_LDSTR16X sel OP_STORE rd rn rm)
		 (sequence ()
			   (sem-op (add rn rm) rd mode sel)
			   )
		 ()
		 )

    (dni_wrapper (%sym name "x")
		 (%str "store" mode " indexed")
		 ()
		 (%str name " $rd6,[$rn6,$direction$rm6]")
		 (+ OP4_LDSTRX sel OP_STORE (f-opc-19-4 #x0)  (f-dc-22-1 #x0) (f-dc-21-1 #x0) rd6 rn6 direction rm6)
		 (sequence ()
			   (if (ifield f-addsubx)
			       (sem-op (sub rn6 rm6) rd6 mode sel)
			       (sem-op (add rn6 rm6) rd6 mode sel)
			       ))
		 ()
		 )

    (dnmi (%sym name "x.l")
	  (%str "store" mode " indexed")
	  (NO-DIS)
	  (%str name ".l $rd6,[$rn6,$direction$rm6]")
	  (emit  (%sym name "x")  rd6 rn6 direction rm6)
	  )





    (dni_wrapper (%sym name "p16")
		 (%str "store " mode " postmodify")
		 (SHORT-INSN)
		 (%str name " $rd,[$rn],$rm")
		 (+ OP4_LDSTR16P sel OP_STORE rd rn rm)
		 (sequence ()
			   (sem-op rn rd mode sel)
			   (set rn (add rn rm))
			   )
		 ()
		 )

    (dni_wrapper (%sym name "p")
		 (%str "store " mode " postmodify")
		 ()
		 (%str name " $rd6,[$rn6],$direction$rm6")
		 (+ OP4_LDSTRP sel OP_STORE (f-opc-19-4 #x0) (f-dc-22-2 #x0) rd6 rn6 direction rm6)
		 (sequence ()
			   (sem-op rn6 rd6 mode sel)
			   (if (ifield f-addsubx)
			       (set rn6	(sub rn6 rm6))
			       (set rn6 (add rn6 rm6)))
			   )
		 ()
		 )
    (dnmi (%sym name "p.l")
	  (%str "store " mode " postmodify")
	  (NO-DIS)
	  (%str name ".l $rd6,[$rn6],$direction$rm6")
	  (emit (%sym name "p") rd6 rn6 direction rm6)
	  )

    (dni_wrapper (%sym name "d16")
		 (%str "store " mode " displacement")
		 (SHORT-INSN IMM3)
		 (%str name " $rd,[$rn,$disp3]")
		 (+ OP4_LDSTR16D sel OP_STORE rd rn disp3) ;; convert size to 'B'
		 (sequence ((SI effa)
			    (SI scale))
			   (ConvertSelectorToShift sel scale)
			   (set effa (add rn (sll disp3 scale)))
			   (sem-op effa rd mode sel)
			   )
		 ()
		 )

    (dni_wrapper (%sym name "d")
		 (%str "store " mode " displacement")
		 ()
		 (%str name " $rd6,[$rn6,$dpmi$disp11]")
		 (+ OP4_LDSTRD sel OP_STORE PMOD_DISP rd6 rn6 dpmi disp11)
		 (sequence ((SI effa)
			    (SI scale))
			   (ConvertSelectorToShift sel scale)
			   (if dpmi
			       (set effa (sub rn6 (sll disp11 scale)))
			       (set effa (add rn6 (sll disp11 scale)))
			       )
			   (sem-op effa rd6 mode sel)
			   )
		 ()
		 )

    (dnmi (%sym name "d.l")
	  (%str "store " mode " displacement")
	  (NO-DIS)
	  (%str name ".l $rd6,[$rn6,$dpmi$disp11]")
	  (emit (%sym name "d") rd6 rn6 dpmi disp11)
	  )


    (dni_wrapper (%sym name "dpm")
		 (%str "store " mode " displacement post-modify")
		 ()
		 (%str name " $rd6,[$rn6],$dpmi$disp11")
		 (+ OP4_LDSTRD sel OP_STORE PMOD_POST rd6 rn6 dpmi disp11) ;; convert size to 'B'
		 (sequence ((SI scale))
			   (ConvertSelectorToShift sel scale)
			   (sem-op rn6 rd6 mode sel)
			   (if dpmi
			       (set rn6 (sub rn6 (sll disp11 scale)))
			       (set rn6 (add rn6 (sll disp11 scale)))
			       )
			   )
		 ()
		 )
    (dnmi (%sym name "dpm.l")
	  (%str "store " mode " displacement post-modify")
	  (NO-DIS)
	  (%str name ".l $rd6,[$rn6],$dpmi$disp11")
	  (emit (%sym name "dpm") rd6 rn6 dpmi disp11)
	  )

    ;; macro form with a zero displacement
    (dnmi (%sym name "ds0") "store w 0 disp"
	  (SHORT-INSN IMM3)
	  (%str name " $rd,[$rn]")
	  (emit (%sym name "d16") rd rn (disp3 0))
	  )

    (dnmi (%sym name "dl0")  "store w 0 disp"
	  ()
	  (%str name " $rd6,[$rn6]")
	  (emit (%sym name "d") rd6 rn6 (dpmi 0) (disp11 0))
	  )

    (dnmi (%sym name "dl0.l")  "store w 0 disp"
	  (NO-DIS)
	  (%str name ".l $rd6,[$rn6]")
	  (emit (%sym name "d") rd6 rn6 (dpmi 0) (disp11 0))
	  )



    )
  )

(store-insn strb QI OPW_BYTE store-to-ea)
(store-insn strh HI OPW_SHORT store-to-ea)
(store-insn str  SI OPW_WORD store-to-ea)
(store-insn strd DI OPW_DOUBLE store-double-to-ea)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MOV<COND> RD,RN
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define-pmacro (move-insns name cond g-op)
  (begin
    (dni_wrapper (%sym "cmov16" cond)
		 (%str "move register " cond)
		 (SHORT-INSN)
		 (%str "mov" name " $rd,$rn")
		 (+ OP4_FLOW16 (%sym "OPC_" cond) (f-opc-8-1 #x0) (f-dc-9-1 #x0) rd rn)
		 (if (g-op)
		     (set rd rn))
		 ()
		 )

    (dni_wrapper (%sym "cmov" cond)
		 (%str "move register " cond)
		 ()
		 (%str "mov" name " $rd6,$rn6")
		 (+ OP4_MISC (%sym "OPC_" cond) (f-opc-8-1 #x0) (f-dc-9-1 #x0) (f-opc-19-4 #x2) (f-dc-25-6 #x0) rd6 rn6)
		 (if (g-op)
		     (set rd6 rn6))
		 ()
		 )
    (dnmi (%sym "cmov.l" cond)
	  (%str "move register " cond)
	  (NO-DIS)
	  (%str "mov" name ".l $rd6,$rn6")
	  (emit (%sym "cmov" cond) rd6 rn6)
	  )



    )
  )

					; basic conditional moves
(move-insns "eq"    EQ	   (%pmacro () (eq zbit #x1)))
(move-insns "ne"    NE	   (%pmacro () (eq zbit #x0)))
(move-insns "gtu"   GTU	   (%pmacro () (and BI cbit (not BI zbit))))
(move-insns "gteu"  GTEU   (%pmacro () (eq cbit #x1)))
(move-insns "lteu"  LTEU   (%pmacro () (or BI (not BI cbit) zbit)))
(move-insns "ltu"   LTU	   (%pmacro () (eq cbit #x0)))
(move-insns "gt"    GT	   (%pmacro () (and BI (not BI zbit) (eq vbit nbit))))
(move-insns "gte"   GTE	   (%pmacro () (eq vbit nbit)))
(move-insns "lt"    LT	   (%pmacro () (xor BI vbit nbit)))
(move-insns "lte"   LTE	   (%pmacro () (or BI zbit (xor vbit nbit))))

					; unconditional move
(move-insns ""      B      (%pmacro () #x1))


					; floating point condition codes (floating point instructions)
(move-insns "beq"   BEQ    (%pmacro () (or BI bzbit bzbit)))
(move-insns "bne"   BNE    (%pmacro () (not BI bzbit)))
(move-insns "blt"   BLT    (%pmacro () (and BI bnbit (not bzbit))))
(move-insns "blte"  BLTE   (%pmacro () (or BI bnbit bzbit)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MOVTS RD,RN
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; 16 bits form exists for group zero ( M1 and M0 equals to zero ) only

(dni_wrapper movts16
	     "move to special reg"
	     (SHORT-INSN)
	     "movts $sn,$rd"
	     (+ OP4_FLOW16 (f-opc-8-5 #x10) (f-dc-9-1 #x0) rd sn) ;; rd is source for movts
	     (set sn rd)
	     ()
	     )

(define-pmacro (op-mmr-movts name sdreg code)
  (begin

    (dni_wrapper (%sym "movts" name)
		 (%str "move to " name)
		 ()
		 (%str "movts $" sdreg ",$rd6")
		 (+ OP4_MISC (f-dc-7-4 #x0) (f-opc-8-1 #x1) (f-dc-9-1 #x0) (f-opc-19-4 #x2) (f-dc-25-4 #x0) (f-dc-21-2 code) sdreg rd6);; rd is source for movts
		 (set sdreg rd6)
		 ()
		 )

    (dnmi (%sym "movts.l" name)
	  (%str "move to " name)
	  (NO-DIS)
	  (%str "movts.l $" sdreg ",$rd6")
	  (emit (%sym "movts" name) sdreg rd6)
	  )




    )
  )

(op-mmr-movts  6    sn6    #x0)
(op-mmr-movts  dma  sndma  #x1)
(op-mmr-movts  mem  snmem  #x2)
(op-mmr-movts  mesh snmesh #x3)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MOVFS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(dni_wrapper movfs16
	     "move from special register"
	     (SHORT-INSN)
	     "movfs $rd,$sn"
	     (+ OP4_FLOW16 (f-opc-8-5 #x11) (f-dc-9-1 #x0) rd sn)
	     (set rd sn)
	     ()
	     )



(define-pmacro (op-mmr-movfs name snreg code)
  (begin

    (dni_wrapper (%sym "movfs" name)
		 (%str "move from " name)
		 ()
		 (%str "movfs $rd6,$" snreg)
		 (+ OP4_MISC (f-dc-7-4 #x1) (f-opc-8-1 #x1) (f-dc-9-1 #x0) (f-opc-19-4 #x2) (f-dc-25-4 #x0) (f-dc-21-2 code) rd6 snreg)
		 (set rd6 snreg)
		 ()
		 )

    (dnmi (%sym "movfs.l" name)
	  (%str "move from " name)
	  (NO-DIS)
	  (%str "movfs.l $rd6,$" snreg)
	  (emit (%sym "movfs" name) rd6 snreg)
	  )



    )
  )

(op-mmr-movfs  6    sn6    #x0)
(op-mmr-movfs  dma  sndma  #x1)
(op-mmr-movfs  mem  snmem  #x2)
(op-mmr-movfs  mesh snmesh #x3)





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; NOP 0x1a2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(dni_wrapper nop
	     "no-operation"
	     (SHORT-INSN)
	     "nop"
	     (+ OP4_FLOW16 (f-opc-8-5 #x1a) (f-dc-15-7 #x0))
	     (nop)
	     ()
	     )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SNOP 0x3a2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(dni_wrapper snop
	     "no-operation"
	     (SHORT-INSN)
	     "snop"
	     (+ OP4_FLOW16 (f-opc-8-5 #x3a) (f-dc-15-7 #x0))
	     (nop)
	     ()
	     )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; UNIMPL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(dni_wrapper unimpl
	     "not-implemented"
	     ()
	     "unimpl"
	     (+ (f-opc-31-32  #x000F000F))
	     (nop)
	     ()
	     )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; IDLE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(dni idle
  "idle until interrupt"
  (SHORT-INSN)
  "idle"
  (+ OP4_FLOW16 (f-opc-8-5 #x1b) (f-dc-15-7 #x0))
  (sequence ((USI tmpPC))
	(set caibit 0)
	(set tmpPC pc)
	(set pc tmpPC)
  )
  ()
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BKPT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(dni bkpt
     "breakpoint"
     (SHORT-INSN)
     "bkpt"
     (+ OP4_FLOW16 (f-opc-8-5 #x1c) (f-dc-15-7 #x0))
     (sequence ()
     	 (c-call  "epiphany_break" pc)
     	(set pc pc)
     	)
     ()
     )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MBKPT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(dni mbkpt
     "multicorebreakpoint"
     (SHORT-INSN)
     "mbkpt"
     (+ OP4_FLOW16 (f-opc-8-5 #x1c) (f-dc-15-7 #x1))
     ;;;(c-call "epiphany_break" pc)
     (nop) ;; ignore the multi core break point in the simulator
     ()
     )

;;;;;;;;;;;;;;;;
;; RTI
;;;;;;;;;;;;;;;;

(dni rti "return from interrupt" (SHORT-INSN UNCOND-CTI)
  "rti"
  (+ OP4_FLOW16 (f-opc-8-5 #x1d) (f-dc-15-7 #x0))
  (sequence ()
	(set pc (c-call USI "epiphany_rti"))
	;(set gidisablebit 0)
	;(set kmbit 0)
	;(set caibit 1)
	;(set pc (hcr-iret))
  )
  ()
)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; WAND is a wired flag that runs around the chip
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(dni_wrapper wand     "wand"
	     (SHORT-INSN)
	     "wand"
	     (+ OP4_FLOW16 (f-opc-8-5 #x18) (f-dc-15-7 #x0))
	     (set sflagbit 1)
	     ()
	     )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Sync likes wand, but wired OR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(dni_wrapper sync     "sync"
	     (SHORT-INSN)
	     "sync"
	     (+ OP4_FLOW16 (f-opc-8-5 #x1f) (f-dc-15-7 #x0))
	     (nop);;TODO
	     ()
	     )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GIE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(dni_wrapper gien     "global interrupt enable"
	     (SHORT-INSN)
	     "gie"
	     (+ OP4_FLOW16 (f-gien-gidis-9-1 #x0) (f-opc-8-5 #x19) (f-dc-15-6 #x0))
		 ;; Might trigger interrupt
		 (c-call VOID "epiphany_gie")
	     ()
	     )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GIDIS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(dni_wrapper gidis     "global interrupt disable"
	     (SHORT-INSN)
	     "gid"
	     (+ OP4_FLOW16 (f-gien-gidis-9-1 #x1) (f-opc-8-5 #x19) (f-dc-15-6 #x0))
	     (set gidisablebit 1)
	     ()
	     )



;;;;;;;;;;;;;;;;
;; SWI
;;;;;;;;;;;;;;;;

;; Model only immediate 'fire' exception, if gien cleared or masked don't fire and don't check later - no ilat like behavior
;; TODO: Parameter version seems unsupported by assembler. Remove ?
(dni swi_num "software interrupt" (SHORT-INSN UNCOND-CTI)
     "swi $swi_num"
     (+ OP4_FLOW16 (f-opc-8-5 #x1e) (f-trap-swi-9-1 #x0)  swi_num) ;; What do we do with swi_num?
     (sequence ()  (schedule-exception (enum USI H-SCR-STATUS-EXCAUSE-SWI)))
     ()
     )
(dni swi "software interrupt" (ALIAS SHORT-INSN UNCOND-CTI)
     "swi"
     (+ OP4_FLOW16 (f-opc-8-5 #x1e) (f-trap-swi-9-1 #x0) (f-dc-15-6 #x0))
     (sequence ()  (schedule-exception (enum USI H-SCR-STATUS-EXCAUSE-SWI)))
     ()
     )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TRAP #disp3 - simulator only and chip as well - make the same grouop as swi
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Only defining 16-bit form of this instruction.  It exists to support the
;; simulator, by giving us a simple input/output mechanism beyond returning values
;; in registers or memory.
;; TRAP #N  - special sw trap for simulator support;  allows simple i/o using fixed arguments
;; TRAP #0  - write (r0=i/o channel, r1=addr, r2=len) returns status in r0
;; TRAP #1  - read  (r0=i/o channel, r1=addr, r2=len) returns length or -<code> on error
;; TRAP #2  - open  (r0=string path, r1=mode) returns channel# or -<code> on error
;; TRAP #3  - exit  (r0=status code) never returns.
;; TRAP #4  - print "pass\n" and exit
;; TRAP #5  - print "fail\n" and exit
;; TRAP #6  - close  (r0=i/o channel)

(dni trap16 "trap to simulator"
     (SHORT-INSN UNCOND-CTI)
     "trap $trapnum6"
     (+ OP4_FLOW16 (f-opc-8-5 #x1e) (f-trap-swi-9-1 #x1)  trapnum6) ;;  (+ OP4_IMM16 OPI_TRAP (f-rd 0) (f-rn 0) disp3)
     (set (reg SI h-registers 0) (c-call SI "epiphany_trap" pc trapnum6))
     ()
     )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Integer arithmetic instructions 3 address forms
;;   both 16 and 32 bit forms
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define-pmacro (op-rrr name sem-op cond-op)
  (begin
    (dni_wrapper (%sym name "16")
		 (%str name)
		 (SHORT-INSN)
		 (%str name " $rd,$rn,$rm")
		 (+ OP4_ALU16 (%sym "OPB_" (%upcase (%str name))) rd rn rm)
		 (sequence ()
			   (cond-op rn rm)
			   (set rd (sem-op SI rn rm))
			   (set zbit (zflag rd))
			   (set nbit (nflag rd))
			   )
		 ()
		 )

    (dni_wrapper (%sym name)
		 (%str name)
		 ()
		 (%str name " $rd6,$rn6,$rm6")
		 (+ OP4_MISC (%sym "OPB_" (%upcase (%str name))) (f-opc-19-4 #xa) (f-dc-22-3 #x0) rd6 rn6 rm6)
		 (sequence ()
			   (cond-op rn6 rm6)
			   (set rd6 (sem-op SI rn6 rm6))
			   (set zbit (zflag rd6))
			   (set nbit (nflag rd6))
			   )
		 ()
		 )

    (dnmi (%sym name ".l")
	  (%str name)
	  (NO-DIS)
	  (%str name ".l $rd6,$rn6,$rm6")
	  (emit (%sym name) rd6 rn6 rm6)
	  )



    )
  )

;; submacros to set condition codes
;;  NZ are always set to reflect the sign and value of the result
;;  CV are a function of the operator
(define-pmacro (add-vc a b) (sequence ()
				      (set cbit (add-cflag SI a b 0))
				      (set vbit (add-oflag SI a b 0))
				      (set vsbit (or BI vsbit vbit))
				      ))

(define-pmacro (sub-vc a b) (sequence ()
				      (set cbit (not (sub-cflag SI a b 0)))
				      (set vbit (sub-oflag SI a b 0))
				      (set vsbit (or vsbit vbit))
				      ))

(define-pmacro (logic-vc a b) (sequence ()
					(set cbit 0)
					(set vbit 0)
					))

(op-rrr add add add-vc)
(op-rrr sub sub sub-vc)
(op-rrr and and logic-vc)
(op-rrr orr  or  logic-vc)
(op-rrr eor xor logic-vc)

;; Integer arithmetic immediate forms

(define-pmacro (op-rri name code cond-op)
  (begin
    (dni_wrapper (%sym name "i16")
		 (%str name)
		 (SHORT-INSN IMM3)
		 (%str name ".s $rd,$rn,$simm3")
		 (+ OP4_IMM16 code rd rn simm3)
		 (sequence ()
			   (cond-op rn simm3)
			   (set rd (name SI rn simm3))
			   (set zbit (zflag rd))
			   (set nbit (nflag rd))
			   )
		 ()
		 )


    (dni_wrapper (%sym name "i")
		 (%str name)
		 ()
		 (%str name ".l $rd6,$rn6,$simm11")
		 (+ OP4_IMM32 code OPI_25_2_MBZ rd6 rn6 simm11)
		 (sequence ()
			   (cond-op rn6 simm11)
			   (set rd6 (name SI rn6 simm11))
			   (set zbit (zflag rd6))
			   (set nbit (nflag rd6))
			   )
		 ()
		 )

    ;;    (dnmi (%sym name "ri") "relaxed arithmetic immediate" (RELAXED)
    ;;	  (%str name " $rd6,$rn6,$simm11")
    ;;	  (emit (%sym name "i") rd6 rn6 simm11))
    )
  )

(op-rri add OPI_ADD add-vc)
(op-rri sub OPI_SUB sub-vc)

(dnmi addir "relaxable short immediate add" (RELAXABLE IMM3)
      "add $rd,$rn,$simm3"
      (emit addi16 rd rn simm3))

(dnmi addi32r "relaxed long immediate add" (RELAXED)
      "add $rd6,$rn6,$simm11"
      (emit addi rd6 rn6 simm11))

;; Again, but not relaxable so that full sized registers are handled
(dnmi addi32m "relaxed long immediate add" ()
      "add $rd6,$rn6,$simm11"
      (emit addi rd6 rn6 simm11))


(dnmi subir "relaxable short immediate sub" (RELAXABLE IMM3)
      "sub $rd,$rn,$simm3"
      (emit subi16 rd rn simm3))

(dnmi subi32r "relaxed long immediate sub" (RELAXED)
      "sub $rd6,$rn6,$simm11"
      (emit subi rd6 rn6 simm11))

(dnmi subi32m "relaxed long immediate sub" ()
      "sub $rd6,$rn6,$simm11"
      (emit subi rd6 rn6 simm11))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Shift instructions 3 address forms
;;   both 16 and 32 bit forms
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define-pmacro (shift-rrr name sem-op)
  (begin
    (dni_wrapper (%sym name "16")
		 (%str name)
		 (SHORT-INSN)
		 (%str name " $rd,$rn,$rm")
		 (+ OP4_ALU16 (%sym "OPB_" (%upcase (%str name))) rd rn rm)
		 (sequence ()
			   (logic-vc rn rm)
			   (set rd (sem-op SI rn (and rm (const 31))))
			   (set zbit (zflag rd))
			   (set nbit (nflag rd))
			   )
		 ()
		 )

    (dni_wrapper (%sym name)
		 (%str name)
		 ()
		 (%str name " $rd6,$rn6,$rm6")
		 (+ OP4_MISC (%sym "OPB_" (%upcase (%str name))) (f-opc-19-4 #xa) (f-dc-22-3 #x0) rd6 rn6 rm6)
		 (sequence ()
			   (logic-vc rn6 rm6)
			   (set rd6 (sem-op SI rn6 (and rm6 (const 31))))
			   (set zbit (zflag rd6))
			   (set nbit (nflag rd6))
			   )
		 ()
		 )

    (dnmi (%sym name ".l")
	  (%str name)
	  (NO-DIS)
	  (%str name ".l $rd6,$rn6,$rm6")
	  (emit (%sym name) rd6 rn6 rm6)
	  )
    )
  )

(shift-rrr asr sra)
(shift-rrr lsr srl)
(shift-rrr lsl sll)

(define-pmacro (op-shift-rri name shortcode f5 longcode sem-op)
  (begin
    (dni_wrapper (%sym name "i16")
		 (%str name)
		 (SHORT-INSN)
		 (%str name " $rd,$rn,$shift")
		 (+ shortcode (f-opc-4-1 f5) rd rn shift)
		 (sequence ()
			   (logic-vc rn shift)
			   (set rd (sem-op SI rn shift))
			   (set zbit (zflag rd))
			   (set nbit (nflag rd))
			   )
		 ()
		 )
    (dni_wrapper (%sym name "i32")
		 (%str name)
		 ()
		 (%str name " $rd6,$rn6,$shift")
		 (+ OP4_MISC (f-opc-4-1 f5) (f-opc-19-4 longcode) (f-dc-25-6 0) rd6 rn6 shift)
		 (sequence ()
			   (logic-vc rn6 shift)
			   (set rd6 (sem-op SI rn6 shift))
			   (set zbit (zflag rd6))
			   (set nbit (nflag rd6))
			   )
		 ()
		 )

    (dnmi (%sym name "i32.l")
	  (%str name)
	  (NO-DIS)
	  (%str name ".l $rd6,$rn6,$shift")
	  (emit (%sym name "i32") rd6  rn6 shift)
	  )


    )
  )

(op-shift-rri lsr OP4_LSHIFT16 0 #x6 srl)
(op-shift-rri lsl OP4_LSHIFT16 1 #x6 sll)
(op-shift-rri asr OP4_ASHIFT16 0 #xe sra)

;; BITR - bitreversal (FFT)
;;
;; From Dr Dobbs et al.
;;
;; unsigned int v;
;; v = ((v >> 1) & 0x55555555) | ((v & 0x55555555) << 1);  ;; swap odd-even bits
;; v = ((v >> 2) & 0x33333333) | ((v & 0x33333333) << 2);  ;; swap pairs
;; v = ((v >> 4) & 0x0f0f0f0f) | ((v & 0x0f0f0f0f) << 4);  ;; swap nibbles
;; v = ((v >> 8) & 0x00ff00ff) | ((v & 0x00ff00ff) << 8);  ;; swap bytes
;; v =  (v >> 16)              |  (v               << 16); ;; swap halves
(define-pmacro (bit-reversal dest src)
  (sequence ((SI v))
	    (set v src)
	    (set v (or (and (srl v 1) #x55555555) (sll (and v #x55555555) 1)))
	    (set v (or (and (srl v 2) #x33333333) (sll (and v #x33333333) 2)))
	    (set v (or (and (srl v 4) #x0f0f0f0f) (sll (and v #x0f0f0f0f) 4)))
	    (set v (or (and (srl v 8) #x00ff00ff) (sll (and v #x00ff00ff) 8)))
	    (set v (or      (srl v 16)            (sll      v            16)))
	    (set dest v)
	    ))

(dni_wrapper bitr16 "bit reverse short"
	     (SHORT-INSN)
	     ("bitr $rd,$rn")
	     (+ OP4_ASHIFT16 (f-opc-4-1 1) rd rn (f-shift 0))
	     (sequence ()
		       (bit-reversal rd rn)
		       (set zbit (zflag rd))
		       (set nbit (nflag rd))
		       (set cbit 0)
		       (set vbit 0)
		       )
	     ()
	     )

(dni_wrapper bitr "bit reverse"
	     ()
	     ("bitr $rd6,$rn6")
	     (+ OP4_MISC (f-opc-4-1 1) (f-opc-19-4 #xe) (f-dc-25-6 0) rd6 rn6 (f-shift 0))
	     (sequence ()
		       (bit-reversal rd6 rn6)
		       (set zbit (zflag rd6))
		       (set nbit (nflag rd6))
		       (set cbit 0)
		       (set vbit 0)
		       )
	     ()
	     )
(dnmi bitrl "bit reverse l"
      (NO-DIS)
      ("bitr.l $rd6,$rn6")
      (emit bitr rd6 rn6)
      )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Integer arithmetic instructions
;; Extended operation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define-pmacro (op-iextrrr  name  cond-op)
  (begin

    (dni_wrapper (%sym name)
		 (%str name)
		 ()
		 (%str name " $rd6,$rn6,$rm6")
		 (+ OP4_MISC (%sym "OPBE_" (%upcase (%str name))) (f-opc-19-4 #xa) (f-dc-22-2 #x0)  (f-dc-20-1 #x1)
		    rd6 rn6 rm6)
		 (sequence ()
			   ;;  TODO cond operation (cond-op rn6 rm6)
			   ;;(set rd6 (sem-op SI rn6 rm6))
			   (set zbit (zflag rd6))
			   (set nbit (nflag rd6))
			   )
		 ()
		 )

    (dnmi (%sym name ".l")
	  (%str name)
	  (NO-DIS)
	  (%str name ".l $rd6,$rn6,$rm6")
	  (emit (%sym name) rd6  rn6 rm6)
	  )
    )
  )

(op-iextrrr fext  sub-vc)
(op-iextrrr fdep  sub-vc)
(op-iextrrr lfsr  sub-vc)



;; Immediate moves.  The 8 bit form is relaxed if it doesn't fit or is external
;; Move RD,#IMM
(dni_wrapper mov8
	     "mov imm8"
	     (SHORT-INSN)
	     "mov.b $rd,$imm8"
	     (+ OP4_IMM16 (f-opc-4-1 #x0) rd imm8)
	     (set rd (zext SI imm8))
	     ()
	     )

(dnmi mov8r "mov imm8 relaxable"
      (RELAXABLE)
      "mov $rd,$imm8"
      (emit mov8 rd imm8))

(dni_wrapper mov16
	     "mov imm16"
	     ()
	     "mov.l $rd6,$imm16"
	     (+ OP4_IMM32 (f-opc-4-1 #x0) (f-opc-19-4 #x2) (f-dc-28-1 #x0) rd6 imm16)
	     (set rd6 (zext SI imm16))
	     ()
	     )

(dnmi mov16r "mov imm16 relaxable"
      ()
      "mov $rd6,$imm16"
      (emit mov16 rd6 imm16))

;; MOVE TO HIGH WORD
(dni_wrapper movt
	     "movt imm16"
	     ()
	     "movt $rd6,$imm16"
	     (+ OP4_IMM32 (f-opc-4-1 #x0) (f-opc-19-4 #x2) (f-dc-28-1 #x1) rd6 imm16)
	     (set rd6 (or (and SI rd6 (const #xffff)) ; keep low bits of rd
			  (sll SI imm16 (const 16)))) ; replacing just high bits
	     ()
	     )
(dnmi movtl
      "movt imm16"
      (NO-DIS)
      "movt.l $rd6,$imm16"
      (emit movt rd6 imm16)
      )



;; FLOATING POINT OPERATIONS
;; TWO operands
(define-pmacro (op-two_operands-float name code)
  (begin
    (dni_wrapper
      (%sym "f_" name "f16")
      (%str "f_" name)
      (SHORT-INSN)
      (%str "f" name " $rd,$rn,$rm")
      (+ OP4_DSP16 code rd rn rm)
      (sequence ()
	(if
	  (eq  arithmetic-modebit2 0)
	  (sequence ((SF fptemp) (SI sdtmp) (BI bubit) (BI bibit))
	    (set sdtmp  (c-call SI (%str "epiphany_f" name) rd rn rm))

	    ;;All bits are calculated in C
	    (set bzbit  (c-call BI "get_epiphany_fzeroflag" sdtmp))
	    (set bnbit  (c-call BI "get_epiphany_fnegativeflag" sdtmp))
	    (set bvbit  (c-call BI "get_epiphany_foverflowflag" sdtmp))
	    (set bubit  (c-call BI "get_epiphany_funderflowflag" sdtmp))
	    (set bibit  (c-call BI "get_epiphany_finvalidflag" sdtmp))
	    (set bvsbit (or bvsbit bvbit))
	    (set busbit (or busbit bubit))
	    (set bisbit (or bisbit bibit))
	    (set rd sdtmp)
	    (if (or (and invexcenbit bisbit)
		    (or (and ovfexcenbit bvsbit) (and unexcenbit busbit)))
		  (schedule-exception (enum USI H-SCR-STATUS-EXCAUSE-FPU))
		)
	  )
	)
	(if (eq arithmetic-modebit2 1)
	    (sequence ((SI sdtmp))
	      (set sdtmp  (c-call SI (%str "epiphany_i" name) rd rn rm))
	      ;; carry is not connected inb the design (set bcbit bcbit)
	      (set bzbit (zflag sdtmp))
	      (set bnbit (nflag sdtmp))
	      (set rd sdtmp)))
	)

      ()
      )
    (dnmi (%sym "i_" name "f16")
	  (%str "i_" name)
	  (SHORT-INSN NO-DIS)
	  (%str "i" name " $rd,$rn,$rm")
	  (emit (%sym "f_" name "f16") rd rn rm)
    )


    (dni_wrapper
      (%sym "f_" name "f32")
      (%str "f_" name)
      ()
      (%str "f" name " $rd6,$rn6,$rm6")
      (+ OP4_MISC code (f-opc-19-4 #x7) (f-dc-22-3 #x0) rd6 rn6 rm6)
      (sequence ()
	(if
	  (eq arithmetic-modebit2 0)
	  (sequence ((SF fptemp) (SI sdtmp) (BI bubit) (BI bibit))
	    (set sdtmp  (c-call SI (%str "epiphany_f" name) rd6 rn6 rm6))

	    ;;All bits are calculated in C
	    (set bzbit  (c-call BI "get_epiphany_fzeroflag" sdtmp))
	    (set bnbit  (c-call BI "get_epiphany_fnegativeflag" sdtmp))
	    (set bvbit  (c-call BI "get_epiphany_foverflowflag" sdtmp))
	    (set bubit  (c-call BI "get_epiphany_funderflowflag" sdtmp))
	    (set bibit  (c-call BI "get_epiphany_finvalidflag" sdtmp))
	    (set bvsbit (or bvsbit bvbit))
	    (set busbit (or busbit bubit))
	    (set bisbit (or bisbit bibit))

	    (set rd6 sdtmp)

	    (if (or (and invexcenbit bisbit)
		    (or (and ovfexcenbit bvsbit) (and unexcenbit busbit)))
		  (schedule-exception (enum USI H-SCR-STATUS-EXCAUSE-FPU))
		)
	  )
	)
	(if (eq arithmetic-modebit2 1)
	    (sequence ((SI sdtmp))
	      (set sdtmp (c-call SI (%str "epiphany_i" name) rd6 rn6 rm6))
	      ;; carry is not connected inb the design (set bcbit bcbit)
	      (set bzbit (zflag sdtmp))
	      (set bnbit (nflag sdtmp))
	      (set rd6 sdtmp)
	      )
	    )
	)
      ()
      )

    (dnmi (%sym "f_" name "f32.l")
	  (%str "f_" name)
	  (NO-DIS)
	  (%str "f" name ".l $rd6,$rn6,$rm6")
	  (emit  (%sym "f_" name "f32") rd6  rn6 rm6)
	  )
    (dnmi (%sym "i_" name "f32")
	  (%str "i_" name)
	  (NO-DIS)
	  (%str "i" name " $rd6,$rn6,$rm6")
	  (emit  (%sym "f_" name "f32") rd6  rn6 rm6)
	  )
    (dnmi (%sym "i_" name "f32.l")
	  (%str "i_" name)
	  (NO-DIS)
	  (%str "i" name ".l $rd6,$rn6,$rm6")
	  (emit  (%sym "f_" name "f32") rd6  rn6 rm6)
	  )



    )
  )

(op-two_operands-float add OPF_ADD)
(op-two_operands-float sub OPF_SUB)
(op-two_operands-float mul OPF_MUL)
(op-two_operands-float madd OPF_MADD)
(op-two_operands-float msub OPF_MSUB)

;; ONE operands
;; FABS
(define-pmacro (op-fabs-float name code)
  (begin
    (dni_wrapper (%sym "f_" name "f16")
		 (%str "f_" name)
		 (SHORT-INSN)
		 (%str "f" name " rd,rn")
		 (+ OP4_DSP16 code rd rn rn)
		 (sequence ((SF fptemp) (SI sdtmp))

		   ;(set sdtmp  (and rn  #x7fffffff))
		   (set sdtmp  (c-call SI (%str "epiphany_fabs") rd rn rn))


		   (set bnbit  (const SI 0))
		   (set bzbit (eq SI sdtmp  (const SI 0)))

		   ;;TODO subnormal ??
		   (set bvsbit (or bvsbit bvbit))
		   ;;(set busbit (or busbit bubit))
		   ;;(set bisbit (or bisbit bibit))

		   (set rd sdtmp)
		   )
		 ()
		 )

    (dni_wrapper (%sym "f_" name "f32")
		 (%str "f_" name)
		 ()
		 (%str "f" name " $rd6,$rn6")
		 (+ OP4_MISC code (f-opc-19-4 #x7) (f-dc-22-3 #x0) rd6 rn6 rn6)
		 (sequence ((SF fptemp) (SI sdtmp))


		   ;(set sdtmp   (and rn6  #x7fffffff))

		   (set sdtmp  (c-call SI (%str "epiphany_fabs") rd6 rn6 rn6))


		   (set bnbit   (const SI 0))
		   (set bzbit (eq SI sdtmp  (const SI 0)))

		   (set bvsbit (or bvsbit bvbit))
		   ;;(set busbit (or busbit bubit))
		   ;;(set bisbit (or bisbit bibit))

		   (set rd6 sdtmp)

		   )
		 ()
		 )

    (dnmi  (%sym "f_" name "f32.l")
	   (%str "f_" name)
	   (NO-DIS)
	   (%str "f" name ".l $rd6,$rn6")
	   (emit (%sym "f_" name "f32") rd6  rn6)
	   )


    )
  )

(op-fabs-float abs OPF_FABS)


(define-pmacro (op-fix2float-float name code)
  (begin
    (dni_wrapper (%sym "f_" name "f16")
		 (%str "f_" name)
		 (SHORT-INSN)
		 (%str "f" name " $rd,$rn")
		 (+ OP4_DSP16 code frd frn frn)
		 (sequence ((SF fptemp) (SI sdtmp))

		   (set sdtmp  (c-call SI (%str "epiphany_f" name) rd rn rn))

		   (set bnbit (lt SI sdtmp  (const SI 0)))
		   (set bzbit (eq SI sdtmp  (const SI 0)))

		   (set bvsbit (or bvsbit bvbit))
		   ;;(set busbit (or busbit bubit))
		   ;;(set bisbit (or bisbit bibit))

		   (set rd sdtmp)
		   )
		 ()
		 )


    (dni_wrapper (%sym "f_" name "f32")
		 (%str "f_" name)
		 ()
		 (%str "f" name " $rd6,$rn6")
		 (+ OP4_MISC code (f-opc-19-4 #x7) (f-dc-22-3 #x0) rd6 rn6 rn6)
		 (sequence ((SF fptemp) (SI sdtmp))

		   (set sdtmp  (c-call SI (%str "epiphany_f" name) rd6 rn6 rn6))

		   (set bnbit (lt SI sdtmp  (const SI 0)))
		   (set bzbit (eq SI sdtmp  (const SI 0)))

		   (set bvsbit (or bvsbit bvbit))
		   ;;(set busbit (or busbit bubit))
		   ;;(set bisbit (or bisbit bibit))

		   (set rd6 sdtmp)

		   )
		 ()
		 )

    (dnmi (%sym "f_" name "f32.l")
	  (%str "f_" name)
	  (NO-DIS)
	  (%str "f" name ".l $rd6,$rn6")
	  (emit (%sym "f_" name "f32")  rd6 rn6)
	  )
    )
  )

(op-fix2float-float loat OPF_FLOAT)

(define-pmacro (op-float2fix-float name code)
  (begin
    (dni_wrapper (%sym "f_" name "f16")
		 (%str "f_" name)
		 (SHORT-INSN)
		 (%str "f" name " $rd,$rn")
		 (+ OP4_DSP16 code rd rn rn)
		 (sequence ((SF fptemp) (SI sdtmp) (BI bubit) (BI bibit))

		   (set sdtmp  (c-call SI (%str "epiphany_f" name) rd rn rn))

		   (set bzbit (zflag sdtmp))
		   (set bnbit (nflag sdtmp))

		   (set bvbit  (c-call BI "get_epiphany_foverflowflag" sdtmp))
		   (set bubit  (c-call BI "get_epiphany_funderflowflag" sdtmp))
		   (set bibit  (c-call BI "get_epiphany_finvalidflag" sdtmp))

		   (set bvsbit (or bvsbit bvbit))
		   (set busbit (or busbit bubit))
		   (set bisbit (or bisbit bibit))

		   (set rd6 sdtmp)

		   (if (or (and invexcenbit bisbit)
			   (or (and ovfexcenbit busbit)
			       (and unexcenbit bvsbit)))
			 (schedule-exception (enum USI H-SCR-STATUS-EXCAUSE-FPU))
		   )
		   (set rd sdtmp)
		   )
		 ()
		 )



    (dni_wrapper (%sym "f_" name "f32")
		 (%str "f_" name)
		 ()
		 (%str "f" name " $rd6,$rn6")
		 (+ OP4_MISC code (f-opc-19-4 #x7) (f-dc-22-3 #x0) rd6 rn6 rn6)
		 (sequence ((SF fptemp) (SI sdtmp) (BI bubit) (BI bibit))

		   (set sdtmp  (c-call SI (%str "epiphany_f" name) rd6 rn6 rm6))

		   (set bzbit (zflag sdtmp))
		   (set bnbit (nflag sdtmp))

		   (set bvbit  (c-call BI "get_epiphany_foverflowflag" sdtmp))
		   (set bubit  (c-call BI "get_epiphany_funderflowflag" sdtmp))
		   (set bibit  (c-call BI "get_epiphany_finvalidflag" sdtmp))

		   (set bvsbit (or bvsbit bvbit))
		   (set busbit (or busbit bubit))
		   (set bisbit (or bisbit bibit))

		   (set rd6 sdtmp)

		   (if (or (and invexcenbit bisbit)
			   (or (and ovfexcenbit busbit)
			       (and unexcenbit bvsbit)))
			 (schedule-exception (enum USI H-SCR-STATUS-EXCAUSE-FPU))
		   )
		 )
		 ()
	)

    (dnmi (%sym "f_" name "f32.l")
	  (%str "f_" name)
	  (NO-DIS)
	  (%str "f" name ".l $rd6,$rn6")
	  (emit (%sym "f_" name "f32") rd6  rn6)
	  )


    )
  )





(op-float2fix-float ix OPF_FIX)

;; MAC (Multiply and Accumulate Instructions
;; (define-pmacro (op-mac-float name code)
;;   (begin
;;     (dni_wrapper (%sym "fm" name "f16")
;; 	 (%str "fm" name)
;; 	 (SHORT-INSN)
;; 	 (%str "fm" name " $frd,$frn,$frm")
;; 	 (+ OP4_DSP16 code frd frn frm)
;; 	 (sequence ((SF fptemp))
;; 		   (set bvbit 0)
;; 		   (set busbit 0)
;;                    (set fptemp (c-call SF (%str "epiphany_fm" name) frd frm frn))
;; 		   (set bnbit (lt SF fptemp (const SF 0)))
;; 		   (set bzbit (eq SF fptemp (const SF 0)))
;; 		   (set bvsbit (or bvsbit bvbit))
;;                    (set frd fptemp)
;; ;		   (set rd (subword SI frd 0))
;; 		   )
;; 	 ()
;; 	 )

;;     (dni_wrapper (%sym "fm" name "f32")
;; 	 (%str "fm" name)
;; 	 ()
;; 	 (%str "fm" name " $frd6,$frn6,$frm6")
;; 	 (+ OP4_MISC code (f-opc-19-4 #x7) (f-dc-22-3 #x0) frd6 frn6 frm6)
;; 	 (sequence ((SF fptemp))
;; 		   (set bvbit 0)
;; 		   (set busbit 0)
;;                    (set fptemp (c-call SF (%str "epiphany_fm" name) frd6 frm6 frn6))
;; 		   (set bnbit (lt SF fptemp (const SF 0)))
;; 		   (set bzbit (eq SF fptemp (const SF 0)))
;; 		   (set bvsbit (or bvsbit bvbit))
;;                    (set frd6 fptemp)
;; ;		   (set rd6 (subword SI frd6 0))
;; 		   )
;; 	 ()
;; 	 )
;;     )
;; )







					; extended floating point operation


(define-pmacro (op-fextop-float name code)
  (begin

    (dni_wrapper (%sym "f_" name "f32")
		 (%str "f_" name)
		 ()
		 (%str "f" name " $frd6,$frn6")
		 (+ OP4_MISC code (f-opc-19-4 #x7) (f-dc-22-2 #x0) (f-dc-20-1 #x1) frd6 frn6 frn6)
		 (sequence ((SF fptemp))
			   (set bvbit 0)
			   (set busbit 0)
			   (set fptemp (c-call SF (%str "epiphany_f" name) frn6))
			   (set bnbit (lt SF fptemp (const SF 0)))
			   (set bzbit (eq SF fptemp (const SF 0)))
			   (set bvsbit (or bvsbit bvbit))
			   (set frd6 fptemp)

			   )
		 ()
		 )


    (dnmi (%sym "f_" name "f32.l")
	  (%str "f_" name)
	  (NO-DIS)
	  (%str "f" name ".l $frd6,$frn6")
	  (emit (%sym "f_" name "f32") frd6 frn6)
	  )
    )
  )

(op-fextop-float recip OPF_FRECIP)
(op-fextop-float sqrt  OPF_FSQRT)





