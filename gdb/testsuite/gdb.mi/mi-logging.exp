# Copyright 2012-2018 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

load_lib mi-support.exp
set MIFLAGS "-i=mi"

gdb_exit
if [mi_gdb_start] {
    continue
}

standard_testfile basics.c
set opts {debug}

if [build_executable $testfile.exp $testfile $srcfile $opts] {
    untested "failed to compile"
    return -1
}

if {[mi_run_to_main] < 0} {
    return -1
}

set milogfile [standard_output_file "milog.txt"]

mi_gdb_test "-gdb-set logging file $milogfile" ".*"

mi_gdb_test "-gdb-set logging overwrite on" ".*"

mi_gdb_test "-gdb-set logging on" ".*" "logging on"

mi_step "logged step"

mi_next "logged next"

mi_gdb_test "-gdb-set logging off" ".*" "logging off"

set chan [open $milogfile]
set logcontent [read $chan]
close $chan

set mi_log_prompt "\[(\]gdb\[)\] \[\r\n\]+"

if [regexp "\\^done\[\r\n\]+$mi_log_prompt\\^running\[\r\n\]+\\*running,thread-id=\"all\"\[\r\n\]+$mi_log_prompt\\*stopped,reason=\"end-stepping-range\",.*\[\r\n\]+$mi_log_prompt\\^running\[\r\n\]+\\*running,thread-id=\"all\"\[\r\n\]+$mi_log_prompt\\*stopped,reason=\"end-stepping-range\",.*\[\r\n\]+$mi_log_prompt" $logcontent] {
    pass "log file contents"
} else {
    fail "log file contents"
}

# Now try the redirect, which writes into the file only.

mi_gdb_test "-gdb-set logging redirect on" ".*" "redirect logging on"

send_gdb "1001-gdb-set logging on\n"

set chan [open $milogfile]

# Read GDB output in channel/file CHAN, expect the result.  PATTERN is
# the pattern to match for a PASS.

proc gdb_test_file {chan pattern test} {
    global timeout

    set ticks [expr 10 * $timeout]
    set t 0
    set logcontent ""

    while {1} {
	set r [read $chan]
	append logcontent $r

	if [regexp "$pattern" $logcontent] {
	    pass "$test"
	    break
	} else {
	    incr t
	    if {$t == $ticks} {
		fail "$test (timeout)"
		break
	    }
	    after 100
	}
    }
}

gdb_test_file $chan \
    "1001\\^done\[\r\n\]+$mi_log_prompt" \
    "redirect log file contents, 1"

send_gdb "1002-exec-step\n"
gdb_test_file $chan \
    "1002\\^running\[\r\n\]+\\*running,thread-id=\"all\"\[\r\n\]+$mi_log_prompt\\*stopped,reason=\"end-stepping-range\",.*\[\r\n\]+$mi_log_prompt" \
    "redirect log file contents, 2"

send_gdb "1003-exec-next\n"
gdb_test_file $chan \
    "1003\\^running\[\r\n\]+\\*running,thread-id=\"all\"\[\r\n\]+$mi_log_prompt\\*stopped,reason=\"end-stepping-range\",.*\[\r\n\]+$mi_log_prompt" \
    "redirect log file contents, 3"

close $chan

mi_gdb_test "1004-gdb-set logging off" ".*" "redirect logging off"

# Now try enabling a redirect while GDB is already logging.  This used
# to crash GDB.
with_test_prefix "redirect while already logging" {
    mi_gdb_test "-gdb-set logging redirect off" ".*" \
	"logging redirect off"
    mi_gdb_test "-gdb-set logging on" ".*" \
	"logging on"
    mi_gdb_test "-gdb-set logging redirect on" \
	".*warning: Currently logging .*Turn the logging off and on to make the new setting effective.*" \
	"logging redirect on"
    mi_gdb_test "-gdb-set logging off" ".*" \
	"logging off"
}

mi_gdb_exit

remote_file host delete $milogfile
